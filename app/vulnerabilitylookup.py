"""
Vulnerability-Lookup API client with comprehensive logging and error handling.

API Documentation: https://vulnerability.circl.lu/api/
Base URL: https://vulnerability.circl.lu/api

Endpoints used:
  - GET /vulnerability/cpesearch/{cpe} - Search vulnerabilities by CPE
  - GET /vulnerability/ - List vulnerabilities with filters
  - GET /cisa_kev/ - Get CISA Known Exploited Vulnerabilities
"""

from typing import List, Optional, Dict, Any
import logging
import urllib.parse
import time
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import urllib3

from .config import VULNERABILITY_LOOKUP_BASE, DEFAULT_TIMEOUT

logger = logging.getLogger(__name__)

UA = "CPE-Watch/2.0 (+vulnerability-lookup)"


def build_session(
    https_proxy: Optional[str] = None,
    http_proxy: Optional[str] = None,
    ca_bundle: Optional[str] = None,
    insecure: bool = False,
    timeout: int = DEFAULT_TIMEOUT
) -> requests.Session:
    """
    Build a requests session with retry logic, proxy support, and certificate configuration.

    Args:
        https_proxy: HTTPS proxy URL (e.g., https://user:pass@host:port)
        http_proxy: HTTP proxy URL (e.g., http://user:pass@host:port)
        ca_bundle: Path to custom CA bundle (PEM file)
        insecure: If True, skip TLS verification (not recommended)
        timeout: Request timeout in seconds

    Returns:
        Configured requests.Session object
    """
    session = requests.Session()

    # Configure retry strategy
    retry = Retry(
        total=4,
        backoff_factor=1.0,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=("GET",),
        raise_on_status=False,
    )
    session.mount("https://", HTTPAdapter(max_retries=retry))
    session.mount("http://", HTTPAdapter(max_retries=retry))

    # Configure proxies
    proxies: Dict[str, str] = {}
    if http_proxy:
        proxies["http"] = http_proxy
        logger.debug(f"HTTP proxy configured: {_mask_proxy_credentials(http_proxy)}")
    if https_proxy:
        proxies["https"] = https_proxy
        logger.debug(f"HTTPS proxy configured: {_mask_proxy_credentials(https_proxy)}")
    if proxies:
        session.proxies.update(proxies)

    # Configure TLS/SSL
    if ca_bundle:
        session.verify = ca_bundle
        logger.info(f"Using custom CA bundle: {ca_bundle}")
    elif insecure:
        session.verify = False
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        logger.warning("TLS verification DISABLED - this is insecure!")
    else:
        session.verify = True

    session.timeout = timeout
    logger.debug(f"Session configured with timeout={timeout}s, verify={session.verify}")

    return session


def _mask_proxy_credentials(proxy_url: str) -> str:
    """Mask credentials in proxy URL for safe logging."""
    try:
        parsed = urllib.parse.urlparse(proxy_url)
        if parsed.password:
            masked = parsed._replace(netloc=f"{parsed.username}:****@{parsed.hostname}:{parsed.port}")
            return masked.geturl()
    except Exception:
        pass
    return proxy_url


def _do_get(
    session: requests.Session,
    path: str,
    insecure: bool,
    url_base: str = VULNERABILITY_LOOKUP_BASE,
    params: Optional[Dict[str, Any]] = None,
) -> requests.Response:
    """
    Execute GET request to Vulnerability-Lookup API with logging.

    Args:
        session: Configured requests session
        path: API endpoint path
        insecure: Override TLS verification
        url_base: Base URL for API
        params: Query parameters

    Returns:
        Response object

    Raises:
        requests.RequestException: On network errors
    """
    headers = {
        "User-Agent": UA,
        "Accept": "application/json",
    }
    verify = False if insecure else getattr(session, "verify", True)
    timeout = getattr(session, "timeout", DEFAULT_TIMEOUT)
    full_url = f"{url_base}{path}"

    logger.debug(f"API Request: GET {full_url} params={params}")
    start_time = time.time()

    try:
        response = session.get(full_url, headers=headers, verify=verify, timeout=timeout, params=params)
        elapsed = time.time() - start_time
        logger.debug(f"API Response: {response.status_code} in {elapsed:.2f}s ({len(response.content)} bytes)")
        return response
    except requests.exceptions.SSLError as e:
        logger.error(f"SSL/TLS Error connecting to {full_url}: {e}")
        logger.error("Hint: Check your CA bundle (--ca-bundle) or use --insecure for testing")
        raise
    except requests.exceptions.ProxyError as e:
        logger.error(f"Proxy Error: {e}")
        logger.error("Hint: Check your proxy settings (--http-proxy, --https-proxy)")
        raise
    except requests.exceptions.ConnectionError as e:
        logger.error(f"Connection Error to {full_url}: {e}")
        raise
    except requests.exceptions.Timeout as e:
        logger.error(f"Request Timeout after {timeout}s to {full_url}")
        raise


def _severity_from_score(score: Optional[float]) -> str:
    """Convert CVSS score to severity level."""
    if score is None:
        return "None"
    try:
        value = float(score)
    except Exception:
        return "None"
    if value >= 9.0:
        return "Critical"
    if value >= 7.0:
        return "High"
    if value >= 4.0:
        return "Medium"
    if value > 0.0:
        return "Low"
    return "None"


def _pick_cvss(vuln_data: Dict[str, Any]) -> Dict[str, Any]:
    """Extract best available CVSS metrics (prioritize v4 > v3.1 > v3.0 > v2)."""
    # Vulnerability-Lookup stores CVSS in different formats
    # Check for cvss-metrics array first
    cvss_metrics = vuln_data.get("cvss-metrics", [])

    # Priority order for CVSS versions
    for version_key in ("cvssV4_0", "cvssV3_1", "cvssV3_0", "cvssV2_0"):
        for metric in cvss_metrics:
            if version_key in metric:
                data = metric[version_key]
                score = data.get("baseScore")
                severity = data.get("baseSeverity") or _severity_from_score(score)
                return {
                    "version": data.get("version"),
                    "vector": data.get("vectorString"),
                    "baseScore": score,
                    "baseSeverity": severity,
                }

    # Try metrics object (NVD format)
    metrics = vuln_data.get("metrics", {})
    if isinstance(metrics, dict):
        for key in ("cvssMetricV40", "cvssMetricV31", "cvssMetricV30", "cvssMetricV2"):
            if key in metrics and metrics[key]:
                metric_list = metrics[key]
                if isinstance(metric_list, list) and len(metric_list) > 0:
                    cvss_data = metric_list[0].get("cvssData", {})
                    score = cvss_data.get("baseScore")
                    severity = cvss_data.get("baseSeverity") or _severity_from_score(score)
                    return {
                        "version": cvss_data.get("version"),
                        "vector": cvss_data.get("vectorString"),
                        "baseScore": score,
                        "baseSeverity": severity,
                    }

    # Try cvss3 field (common in many APIs)
    cvss3 = vuln_data.get("cvss3") or vuln_data.get("cvssV3")
    if cvss3:
        if isinstance(cvss3, dict):
            score = cvss3.get("baseScore")
        else:
            score = cvss3
        return {
            "version": "3.x",
            "vector": cvss3.get("vectorString") if isinstance(cvss3, dict) else None,
            "baseScore": score,
            "baseSeverity": _severity_from_score(score),
        }

    # Fallback: try legacy cvss field
    cvss = vuln_data.get("cvss") or vuln_data.get("cvss2")
    if cvss:
        if isinstance(cvss, dict):
            score = cvss.get("baseScore")
        else:
            score = cvss
        return {
            "version": "2.0",
            "vector": None,
            "baseScore": score,
            "baseSeverity": _severity_from_score(score),
        }

    return {"version": None, "vector": None, "baseScore": None, "baseSeverity": "None"}


def extract_metrics(vuln) -> Dict[str, Any]:
    """Extract CVSS metrics from vulnerability data."""
    return _pick_cvss(vuln)


def extract_epss(vuln) -> Dict[str, Any]:
    """Extract EPSS (Exploit Prediction Scoring System) data."""
    epss_data = vuln.get("epss", {})
    if isinstance(epss_data, dict):
        return {
            "score": epss_data.get("epss"),  # Probability of exploitation (0-1)
            "percentile": epss_data.get("percentile"),  # Percentile ranking
        }
    return {"score": None, "percentile": None}


def extract_description(vuln) -> str:
    """Extract vulnerability description."""
    # Try summary field first (Vulnerability-Lookup format)
    summary = vuln.get("summary", "")
    if isinstance(summary, str) and summary.strip():
        return summary.strip()

    # Try descriptions array (NVD/CVE format)
    descriptions = vuln.get("descriptions", [])
    for entry in descriptions:
        if isinstance(entry, dict):
            if entry.get("lang", "").lower() == "en":
                value = entry.get("value", "").strip()
                if value:
                    return value

    # Fallback to any description
    for entry in descriptions:
        if isinstance(entry, dict):
            value = entry.get("value", "").strip()
            if value:
                return value

    # Try cvelistv5 format - containers.cna.descriptions
    containers = vuln.get("containers", {})
    if isinstance(containers, dict):
        cna = containers.get("cna", {})
        if isinstance(cna, dict):
            cna_descriptions = cna.get("descriptions", [])
            for desc in cna_descriptions:
                if isinstance(desc, dict):
                    value = desc.get("value", "").strip()
                    if value:
                        return value

    return ""


def extract_cwes(vuln) -> List[str]:
    """Extract CWE (Common Weakness Enumeration) identifiers."""
    found: List[str] = []

    # Try cwe field (may be a list or single value)
    cwe = vuln.get("cwe")
    if cwe:
        if isinstance(cwe, list):
            for item in cwe:
                cwe_str = str(item).strip()
                if cwe_str and cwe_str not in found:
                    if not cwe_str.startswith("CWE-"):
                        cwe_str = f"CWE-{cwe_str}"
                    found.append(cwe_str)
        else:
            cwe_str = str(cwe).strip()
            if cwe_str:
                if not cwe_str.startswith("CWE-"):
                    cwe_str = f"CWE-{cwe_str}"
                found.append(cwe_str)

    # Try weaknesses array (NVD format)
    weaknesses = vuln.get("weaknesses", [])
    for weakness in weaknesses:
        if isinstance(weakness, dict):
            for desc in weakness.get("description", []):
                if isinstance(desc, dict):
                    value = desc.get("value", "").strip()
                    if value.startswith("CWE-") and value not in found:
                        found.append(value)

    return found


def extract_references(vuln) -> List[Dict[str, Any]]:
    """Extract reference URLs and their metadata."""
    references = []
    refs = vuln.get("references", [])

    for ref in refs:
        if isinstance(ref, dict):
            references.append({
                "url": ref.get("url"),
                "source": ref.get("source"),
                "tags": ref.get("tags") or [],
            })
        elif isinstance(ref, str):
            # Simple URL string
            references.append({
                "url": ref,
                "source": None,
                "tags": [],
            })

    return references


def is_kev(vuln) -> bool:
    """Check if vulnerability is in CISA Known Exploited Vulnerabilities catalog."""
    # Check for KEV data in various formats
    kev_data = vuln.get("kev", {})
    if isinstance(kev_data, dict) and kev_data:
        return True

    # Check for CISA fields
    cisa_fields = ("cisaExploitAdd", "cisaActionDue", "cisaRequiredAction", "cisaVulnerabilityName")
    if any(field in vuln for field in cisa_fields):
        return True

    # Check other field that might indicate KEV
    other = vuln.get("other", {})
    if isinstance(other, dict):
        content = other.get("content", {})
        if isinstance(content, dict) and content.get("type") == "kev":
            return True

    return False


def extract_kev_data(vuln) -> Dict[str, Any]:
    """Extract KEV-specific data (date added, required action, etc.)."""
    kev_info = {}

    # Try kev object
    kev_data = vuln.get("kev", {})
    if isinstance(kev_data, dict):
        kev_info = {
            "dateAdded": kev_data.get("dateAdded"),
            "dueDate": kev_data.get("dueDate"),
            "requiredAction": kev_data.get("requiredAction"),
            "vulnerabilityName": kev_data.get("vulnerabilityName"),
        }

    # Try other.content format
    other = vuln.get("other", {})
    if isinstance(other, dict):
        content = other.get("content", {})
        if isinstance(content, dict) and content.get("type") == "kev":
            kev_info = {
                "dateAdded": content.get("dateAdded"),
                "dueDate": content.get("dueDate"),
                "requiredAction": content.get("requiredAction"),
                "vulnerabilityName": content.get("vulnerabilityName"),
            }

    # Try CISA fields directly
    if not kev_info:
        kev_info = {
            "dateAdded": vuln.get("cisaExploitAdd"),
            "dueDate": vuln.get("cisaActionDue"),
            "requiredAction": vuln.get("cisaRequiredAction"),
            "vulnerabilityName": vuln.get("cisaVulnerabilityName"),
        }

    # Filter out None values
    return {k: v for k, v in kev_info.items() if v is not None}


def fetch_for_cpe(
    session: requests.Session,
    cpe: str,
    since,
    until,
    insecure: bool,
    page: int = 1,
    per_page: int = 100,
    fetch_all_pages: bool = True,
) -> List[dict]:
    """
    Fetch vulnerabilities for a given CPE from Vulnerability-Lookup API.

    Uses the endpoint: GET /vulnerability/cpesearch/{cpe}

    Query Parameters (from API docs):
    - sort_order: 'asc' or 'desc' (default: desc)
    - date_sort: '', 'published', 'updated', 'reserved' (default: updated)
    - per_page: Max results, capped at 100 (default: 30)
    - page: Pagination page number (default: 1)
    - source: Optional source filter e.g., 'cvelistv5', 'nvd' (default: cvelistv5)

    Args:
        session: Requests session with retry configuration
        cpe: CPE 2.3 string to search for
        since: Start datetime for filtering (client-side)
        until: End datetime for filtering (client-side)
        insecure: Skip TLS verification if True
        page: Page number for pagination (default: 1)
        per_page: Results per page, max 100 (default: 100)
        fetch_all_pages: If True, fetch all pages; if False, fetch only requested page

    Returns:
        List of vulnerability dictionaries
    """
    logger.info(f"Fetching vulnerabilities for CPE: {cpe}")
    logger.debug(f"Time window: {since} to {until}")

    # URL-encode the CPE string for the path
    cpe_encoded = urllib.parse.quote(cpe, safe='')

    # Use the correct endpoint: /vulnerability/cpesearch/{cpe}
    endpoint = f"/vulnerability/cpesearch/{cpe_encoded}"

    all_vulnerabilities = []
    current_page = page

    while True:
        # Build query parameters according to API documentation
        params = {
            "page": str(current_page),
            "per_page": str(min(per_page, 100)),
            "sort_order": "desc",
            "date_sort": "updated",
            "source": "cvelistv5",  # Default source
        }

        # Add date filter if available (since parameter)
        if since:
            try:
                since_str = since.strftime("%Y-%m-%d")
                params["since"] = since_str
            except Exception:
                pass

        logger.debug(f"Requesting page {current_page} with params: {params}")

        try:
            response = _do_get(session, endpoint, insecure, params=params)

            if response.status_code == 404:
                logger.info(f"No vulnerabilities found for CPE: {cpe} (404)")
                return []

            if response.status_code != 200:
                logger.warning(f"API returned status {response.status_code} for CPE: {cpe}")
                logger.debug(f"Response body: {response.text[:500]}")
                return []

            try:
                data = response.json()
            except ValueError as e:
                logger.error(f"Invalid JSON response: {e}")
                logger.debug(f"Response content: {response.text[:500]}")
                return []

            # Parse the response - it could be a list directly or wrapped in metadata
            vulnerabilities = []
            metadata = {}

            if isinstance(data, list):
                # Direct list of vulnerabilities
                vulnerabilities = data
                logger.debug(f"Response is a list with {len(vulnerabilities)} items")
            elif isinstance(data, dict):
                # Could be wrapped with metadata
                if "data" in data:
                    vulnerabilities = data.get("data", [])
                    metadata = data.get("metadata", {})
                elif "vulnerabilities" in data:
                    vulnerabilities = data.get("vulnerabilities", [])
                elif "results" in data:
                    vulnerabilities = data.get("results", [])
                else:
                    # Maybe it's a single vulnerability?
                    if "id" in data or "cve_id" in data:
                        vulnerabilities = [data]
                    else:
                        # Try to find any list in the response
                        for key, value in data.items():
                            if isinstance(value, list) and len(value) > 0:
                                vulnerabilities = value
                                break

                logger.debug(f"Response is a dict, extracted {len(vulnerabilities)} vulnerabilities")

            if not vulnerabilities:
                logger.debug(f"No vulnerabilities in page {current_page}")
                break

            all_vulnerabilities.extend(vulnerabilities)
            logger.info(f"Page {current_page}: retrieved {len(vulnerabilities)} vulnerabilities (total: {len(all_vulnerabilities)})")

            # Check if we should fetch more pages
            if not fetch_all_pages:
                break

            # Check pagination metadata
            total_count = metadata.get("count") or metadata.get("total")
            if total_count and len(all_vulnerabilities) >= total_count:
                break

            # If we got fewer results than requested, we're done
            if len(vulnerabilities) < per_page:
                break

            # Safety limit
            if current_page >= 50:
                logger.warning(f"Reached page limit (50 pages, {len(all_vulnerabilities)} vulnerabilities)")
                break

            current_page += 1

        except requests.RequestException as e:
            logger.error(f"Request failed for CPE {cpe}: {e}")
            break

    logger.info(f"Total vulnerabilities fetched for {cpe}: {len(all_vulnerabilities)}")
    return all_vulnerabilities


def fetch_vulnerabilities(
    session: requests.Session,
    insecure: bool,
    since: Optional[str] = None,
    source: Optional[str] = None,
    cwe: Optional[str] = None,
    page: int = 1,
    per_page: int = 100,
) -> List[dict]:
    """
    Fetch vulnerabilities with optional filters using GET /vulnerability/

    Query Parameters (from API docs):
    - source: Optional source filter (e.g., 'CVE', 'GHSA', 'PySec')
    - per_page: Max results, capped at 100 (default: 30)
    - date_sort: Field to sort by ('', 'published', 'updated', 'reserved')
    - sort_order: 'asc' or 'desc'
    - since: Retrieve vulnerabilities published/updated after date
    - page: Pagination page number
    - cwe: Filter by specific CWE ID
    - light: If '1', returns only (vulnerability_id, source)

    Args:
        session: Requests session
        insecure: Skip TLS verification
        since: Date string for filtering (YYYY-MM-DD)
        source: Source filter
        cwe: CWE filter
        page: Page number
        per_page: Results per page

    Returns:
        List of vulnerability dictionaries
    """
    endpoint = "/vulnerability/"

    params = {
        "page": str(page),
        "per_page": str(min(per_page, 100)),
        "sort_order": "desc",
        "date_sort": "updated",
    }

    if since:
        params["since"] = since
    if source:
        params["source"] = source
    if cwe:
        params["cwe"] = cwe

    try:
        response = _do_get(session, endpoint, insecure, params=params)

        if response.status_code != 200:
            logger.warning(f"API returned status {response.status_code}")
            return []

        data = response.json()

        if isinstance(data, list):
            return data
        elif isinstance(data, dict):
            return data.get("data", data.get("vulnerabilities", data.get("results", [])))

    except Exception as e:
        logger.error(f"Failed to fetch vulnerabilities: {e}")

    return []


def fetch_cisa_kev(
    session: requests.Session,
    insecure: bool,
    page: int = 1,
    per_page: int = 100,
) -> List[dict]:
    """
    Fetch CISA Known Exploited Vulnerabilities using GET /cisa_kev/

    Args:
        session: Requests session
        insecure: Skip TLS verification
        page: Page number
        per_page: Results per page

    Returns:
        List of KEV entries
    """
    endpoint = "/cisa_kev/"

    params = {
        "page": page,
        "per_page": min(per_page, 100),
    }

    try:
        response = _do_get(session, endpoint, insecure, params=params)

        if response.status_code != 200:
            logger.warning(f"CISA KEV API returned status {response.status_code}")
            return []

        data = response.json()

        # Response format: [{"metadata": {...}, "data": [...]}]
        if isinstance(data, list) and len(data) > 0:
            first = data[0]
            if isinstance(first, dict) and "data" in first:
                return first.get("data", [])
            return data
        elif isinstance(data, dict):
            return data.get("data", [])

    except Exception as e:
        logger.error(f"Failed to fetch CISA KEV: {e}")

    return []


def fetch_epss(
    session: requests.Session,
    vulnerability_id: str,
    insecure: bool = False,
) -> Optional[Dict[str, Any]]:
    """
    Fetch EPSS score for a specific vulnerability using GET /epss/{vulnerability_id}

    Args:
        session: Requests session
        vulnerability_id: CVE ID (e.g., 'CVE-2021-44228')
        insecure: Skip TLS verification

    Returns:
        Dict with EPSS data or None if not found
        Example: {"epss": 0.97, "percentile": 0.99}
    """
    # URL-encode the vulnerability ID
    vuln_id_encoded = urllib.parse.quote(vulnerability_id, safe='')
    endpoint = f"/epss/{vuln_id_encoded}"

    try:
        response = _do_get(session, endpoint, insecure)

        if response.status_code == 404:
            logger.debug(f"No EPSS score found for {vulnerability_id}")
            return None

        if response.status_code == 502:
            logger.warning(f"EPSS service returned bad gateway for {vulnerability_id}")
            return None

        if response.status_code == 503:
            logger.warning("EPSS service unavailable")
            return None

        if response.status_code != 200:
            logger.warning(f"EPSS API returned status {response.status_code} for {vulnerability_id}")
            return None

        data = response.json()

        # Extract EPSS score and percentile
        if isinstance(data, dict):
            return {
                "epss": data.get("epss"),
                "percentile": data.get("percentile"),
            }

    except Exception as e:
        logger.debug(f"Failed to fetch EPSS for {vulnerability_id}: {e}")

    return None


def fetch_epss_bulk(
    session: requests.Session,
    vulnerability_ids: List[str],
    insecure: bool = False,
) -> Dict[str, Dict[str, Any]]:
    """
    Fetch EPSS scores for multiple vulnerabilities.

    Args:
        session: Requests session
        vulnerability_ids: List of CVE IDs
        insecure: Skip TLS verification

    Returns:
        Dict mapping CVE ID to EPSS data
    """
    results = {}

    for vuln_id in vulnerability_ids:
        epss_data = fetch_epss(session, vuln_id, insecure)
        if epss_data:
            results[vuln_id] = epss_data

    logger.info(f"Fetched EPSS scores for {len(results)}/{len(vulnerability_ids)} vulnerabilities")
    return results


def fetch_cwe_details(
    session: requests.Session,
    cwe_id: str,
    insecure: bool = False,
) -> Optional[Dict[str, Any]]:
    """
    Fetch detailed information about a CWE using GET /cwe/{cwe_id}

    Args:
        session: Requests session
        cwe_id: CWE ID (e.g., 'CWE-79' or just '79')
        insecure: Skip TLS verification

    Returns:
        Dict with CWE details or None if not found
    """
    # Normalize CWE ID (ensure it starts with CWE-)
    if not cwe_id.upper().startswith("CWE-"):
        cwe_id = f"CWE-{cwe_id}"

    # URL-encode the CWE ID
    cwe_id_encoded = urllib.parse.quote(cwe_id, safe='')
    endpoint = f"/cwe/{cwe_id_encoded}"

    try:
        response = _do_get(session, endpoint, insecure)

        if response.status_code == 404:
            logger.debug(f"CWE not found: {cwe_id}")
            return None

        if response.status_code != 200:
            logger.warning(f"CWE API returned status {response.status_code} for {cwe_id}")
            return None

        data = response.json()
        return data

    except Exception as e:
        logger.debug(f"Failed to fetch CWE details for {cwe_id}: {e}")

    return None


def test_api_connection(session: requests.Session, insecure: bool = False) -> Dict[str, Any]:
    """
    Test connectivity to the Vulnerability-Lookup API.

    Returns:
        Dict with status information
    """
    result = {
        "success": False,
        "api_base": VULNERABILITY_LOOKUP_BASE,
        "endpoints_tested": [],
        "errors": [],
    }

    # Test the main vulnerability endpoint with minimal data
    test_endpoints = [
        ("/vulnerability/", {"per_page": "1", "light": "1"}),
        ("/cisa_kev/", {"per_page": "1"}),
    ]

    for endpoint, params in test_endpoints:
        try:
            logger.info(f"Testing API endpoint: {endpoint}")
            response = _do_get(session, endpoint, insecure, params=params)

            endpoint_result = {
                "endpoint": endpoint,
                "status": response.status_code,
                "success": response.status_code == 200,
            }

            # Try to get response size
            try:
                data = response.json()
                if isinstance(data, list):
                    endpoint_result["items"] = len(data)
                elif isinstance(data, dict):
                    endpoint_result["items"] = len(data.get("data", data.get("results", [])))
            except Exception:
                pass

            result["endpoints_tested"].append(endpoint_result)

            if response.status_code == 200:
                result["success"] = True
                logger.info(f"API endpoint {endpoint} is accessible")
            else:
                logger.warning(f"API endpoint {endpoint} returned {response.status_code}")

        except Exception as e:
            result["errors"].append({
                "endpoint": endpoint,
                "error": str(e),
            })
            logger.error(f"Failed to connect to {endpoint}: {e}")

    return result

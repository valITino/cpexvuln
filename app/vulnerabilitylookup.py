from typing import List, Optional, Dict, Any
import logging
import re
import time
import urllib.parse
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import urllib3

from .config import VULNERABILITY_LOOKUP_BASE, DEFAULT_TIMEOUT, NVD_API_BASE, NVD_API_KEY
from .utils import parse_iso

logger = logging.getLogger(__name__)

UA = "CPE-Watch/2.0 (+vulnerability-lookup)"

_EPSS_CACHE: Dict[str, Dict[str, Optional[float]]] = {}
_EPSS_FIRST_CACHE: Dict[str, Dict[str, Optional[float]]] = {}
_NVD_CACHE: Dict[str, Dict[str, Any]] = {}
_KEV_CACHE: Dict[str, Any] = {"expires_at": 0.0, "data": {}}
FIRST_EPSS_API_BASE = "https://api.first.org/data/v1/epss"
_CVE_ID_RE = re.compile(r"^CVE-\d{4}-\d{4,}$", re.IGNORECASE)


def _normalize_api_base(url_base: str) -> str:
    base = (url_base or "").strip()
    if not base:
        return ""
    base = base.rstrip("/")
    if base.endswith("/api") or base.endswith("/api/v1"):
        return base
    return f"{base}/api"


def build_session(https_proxy=None, http_proxy=None, ca_bundle=None, insecure=False, timeout=DEFAULT_TIMEOUT):
    """Build a requests session with retry logic and proxy support."""
    session = requests.Session()
    retry = Retry(
        total=4,
        backoff_factor=1.0,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=("GET",),
        raise_on_status=False,
    )
    session.mount("https://", HTTPAdapter(max_retries=retry))
    session.mount("http://", HTTPAdapter(max_retries=retry))

    proxies: Dict[str, str] = {}
    if http_proxy:
        proxies["http"] = http_proxy
    if https_proxy:
        proxies["https"] = https_proxy
    if proxies:
        session.proxies.update(proxies)

    if ca_bundle:
        session.verify = ca_bundle
    session.timeout = timeout

    if insecure:
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    return session


def _do_get(
    session: requests.Session,
    path: str,
    insecure: bool,
    url_base: str = VULNERABILITY_LOOKUP_BASE,
    params: Optional[Dict[str, Any]] = None,
):
    """Execute GET request to Vulnerability-Lookup API."""
    headers = {
        "User-Agent": UA,
        "Accept": "application/json",
    }
    verify = False if insecure else getattr(session, "verify", True)
    timeout = getattr(session, "timeout", DEFAULT_TIMEOUT)
    base = _normalize_api_base(url_base)
    full_url = f"{base}{path}"
    return session.get(full_url, headers=headers, verify=verify, timeout=timeout, params=params)


def _severity_from_score(score: Optional[float]) -> str:
    """Convert CVSS score to severity level."""
    if score is None:
        return "None"
    try:
        value = float(score)
    except Exception:
        return "None"
    if value >= 9.0:
        return "Critical"
    if value >= 7.0:
        return "High"
    if value >= 4.0:
        return "Medium"
    if value > 0.0:
        return "Low"
    return "None"


def _empty_cvss_metrics() -> Dict[str, Any]:
    return {"version": None, "vector": None, "baseScore": None, "baseSeverity": "None"}


def _iter_cvss_metrics(vuln_data: Dict[str, Any]):
    cvss_metrics = vuln_data.get("cvss-metrics", [])
    if isinstance(cvss_metrics, list):
        for metric in cvss_metrics:
            yield metric

    containers = vuln_data.get("containers", {})
    if isinstance(containers, dict):
        cna = containers.get("cna", {})
        if isinstance(cna, dict):
            cna_metrics = cna.get("metrics", [])
            if isinstance(cna_metrics, list):
                for metric in cna_metrics:
                    yield metric


def _normalize_cvss_entry(entry: Dict[str, Any], default_version: Optional[str] = None) -> Optional[Dict[str, Any]]:
    if not isinstance(entry, dict):
        return None
    cvss_data = entry.get("cvssData") or entry.get("cvss_data") or {}
    if isinstance(cvss_data, dict) and cvss_data:
        score = cvss_data.get("baseScore")
        if score is None:
            score = entry.get("baseScore")
        severity = cvss_data.get("baseSeverity") or entry.get("baseSeverity") or entry.get("severity")
        vector = cvss_data.get("vectorString") or entry.get("vectorString")
        version = cvss_data.get("version") or default_version
        return {
            "version": version,
            "vector": vector,
            "baseScore": score,
            "baseSeverity": severity or _severity_from_score(score),
        }
    score = entry.get("baseScore")
    if score is None:
        return None
    return {
        "version": entry.get("version") or default_version,
        "vector": entry.get("vectorString"),
        "baseScore": score,
        "baseSeverity": entry.get("baseSeverity") or entry.get("severity") or _severity_from_score(score),
    }


def _pick_nvd_cvss(metrics: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    if not isinstance(metrics, dict):
        return None
    version_map = [
        ("cvssMetricV40", "4.0"),
        ("cvssMetricV31", "3.1"),
        ("cvssMetricV30", "3.0"),
        ("cvssMetricV2", "2.0"),
    ]
    for key, default_version in version_map:
        entries = metrics.get(key) or metrics.get(key.lower())
        if isinstance(entries, list):
            for entry in entries:
                normalized = _normalize_cvss_entry(entry, default_version)
                if normalized and normalized.get("baseScore") is not None:
                    return normalized
        elif isinstance(entries, dict):
            normalized = _normalize_cvss_entry(entries, default_version)
            if normalized and normalized.get("baseScore") is not None:
                return normalized
    return None


def _pick_cvss(vuln_data: Dict[str, Any]) -> Dict[str, Any]:
    """Extract best available CVSS metrics (prioritize v4 > v3.1 > v3.0 > v2)."""
    # Vulnerability-Lookup stores CVSS in different formats
    # Check for cvss-metrics array first
    cvss_metrics = list(_iter_cvss_metrics(vuln_data))

    # Priority order for CVSS versions
    for version_key in ("cvssV4_0", "cvssV3_1", "cvssV3_0", "cvssV2_0"):
        for metric in cvss_metrics:
            if version_key in metric:
                data = metric[version_key]
                score = data.get("baseScore")
                severity = data.get("baseSeverity") or _severity_from_score(score)
                return {
                    "version": data.get("version"),
                    "vector": data.get("vectorString"),
                    "baseScore": score,
                    "baseSeverity": severity,
                }

    # NVD format (metrics -> cvssMetricV31 / cvssMetricV30 / cvssMetricV2)
    for metrics in (
        vuln_data.get("metrics"),
        _get_nested(vuln_data, "cve", "metrics"),
    ):
        normalized = _pick_nvd_cvss(metrics) if isinstance(metrics, dict) else None
        if normalized:
            return normalized

    # Fallback: try legacy cvss field
    cvss = vuln_data.get("cvss")
    if cvss:
        return {
            "version": "2.0",
            "vector": None,
            "baseScore": cvss,
            "baseSeverity": _severity_from_score(cvss),
        }

    return _empty_cvss_metrics()


def extract_metrics(vuln) -> Dict[str, Any]:
    """Extract CVSS metrics from vulnerability data."""
    return _pick_cvss(vuln)


def _request_json(
    session: requests.Session,
    url: str,
    insecure: bool,
    params: Optional[Dict[str, Any]] = None,
    extra_headers: Optional[Dict[str, str]] = None,
):
    headers = {
        "User-Agent": UA,
        "Accept": "application/json",
    }
    if extra_headers:
        headers.update(extra_headers)
    verify = False if insecure else getattr(session, "verify", True)
    timeout = getattr(session, "timeout", DEFAULT_TIMEOUT)
    return session.get(url, headers=headers, verify=verify, timeout=timeout, params=params)


def extract_epss(vuln) -> Dict[str, Any]:
    """Extract EPSS (Exploit Prediction Scoring System) data."""
    epss_data = vuln.get("epss", {})
    if isinstance(epss_data, dict):
        return {
            "score": _parse_float(epss_data.get("epss")),  # Probability of exploitation (0-1)
            "percentile": _parse_float(epss_data.get("percentile")),  # Percentile ranking
        }
    if isinstance(epss_data, list) and epss_data:
        entry = epss_data[0]
        if isinstance(entry, dict):
            return {
                "score": _parse_float(entry.get("epss") or entry.get("score")),
                "percentile": _parse_float(entry.get("percentile")),
            }
    if isinstance(epss_data, (int, float, str)):
        return {"score": _parse_float(epss_data), "percentile": None}
    metrics = vuln.get("metrics")
    if isinstance(metrics, dict):
        metrics_score = metrics.get("epss") or metrics.get("epssScore") or metrics.get("epss_score")
        metrics_percentile = metrics.get("epssPercentile") or metrics.get("epss_percentile")
        if metrics_score is not None or metrics_percentile is not None:
            return {
                "score": _parse_float(metrics_score),
                "percentile": _parse_float(metrics_percentile),
            }
    epss_data = vuln.get("epssData")
    if isinstance(epss_data, dict):
        return {
            "score": _parse_float(epss_data.get("epss") or epss_data.get("score")),
            "percentile": _parse_float(epss_data.get("percentile")),
        }
    return {"score": None, "percentile": None}


def fetch_epss_first(session: requests.Session, vulnerability_id: str, insecure: bool) -> Dict[str, Optional[float]]:
    """Fetch EPSS data from FIRST for a vulnerability ID."""
    normalized_id = _normalize_cve_id(vulnerability_id)
    if not normalized_id:
        return {"score": None, "percentile": None}

    cache_key = normalized_id
    cached = _EPSS_FIRST_CACHE.get(cache_key)
    if cached is not None:
        return cached

    try:
        response = _request_json(
            session,
            FIRST_EPSS_API_BASE,
            insecure,
            params={"cve": cache_key},
        )
        if response.status_code == 404:
            _EPSS_FIRST_CACHE[cache_key] = {"score": None, "percentile": None}
            return _EPSS_FIRST_CACHE[cache_key]
        response.raise_for_status()
        payload = response.json()
    except (requests.RequestException, ValueError):
        return {"score": None, "percentile": None}

    score = None
    percentile = None
    if isinstance(payload, dict):
        data = payload.get("data")
        if isinstance(data, list) and data:
            entry = data[0]
            if isinstance(entry, dict):
                score = _parse_float(entry.get("epss"))
                percentile = _parse_float(entry.get("percentile"))

    result = {"score": score, "percentile": percentile}
    _EPSS_FIRST_CACHE[cache_key] = result
    return result


def extract_description(vuln) -> str:
    """Extract vulnerability description."""
    # Try summary field first
    summary = vuln.get("summary", "").strip()
    if summary:
        return summary

    # Try descriptions array (similar to NVD format)
    descriptions = vuln.get("descriptions", [])
    for entry in descriptions:
        if isinstance(entry, dict):
            if entry.get("lang", "").lower() == "en":
                value = entry.get("value", "").strip()
                if value:
                    return value

    # Fallback to any description
    for entry in descriptions:
        if isinstance(entry, dict):
            value = entry.get("value", "").strip()
            if value:
                return value

    containers = vuln.get("containers", {})
    if isinstance(containers, dict):
        cna = containers.get("cna", {})
        if isinstance(cna, dict):
            cna_descriptions = cna.get("descriptions", [])
            for entry in cna_descriptions:
                if isinstance(entry, dict):
                    if entry.get("lang", "").lower() == "en":
                        value = entry.get("value", "").strip()
                        if value:
                            return value
            for entry in cna_descriptions:
                if isinstance(entry, dict):
                    value = entry.get("value", "").strip()
                    if value:
                        return value

    return ""


def extract_cwes(vuln) -> List[str]:
    """Extract CWE (Common Weakness Enumeration) identifiers."""
    found: List[str] = []

    # Try cwe field (may be a list or single value)
    cwe = vuln.get("cwe")
    if cwe:
        if isinstance(cwe, list):
            for item in cwe:
                cwe_str = str(item).strip()
                if cwe_str and cwe_str not in found:
                    if not cwe_str.startswith("CWE-"):
                        cwe_str = f"CWE-{cwe_str}"
                    found.append(cwe_str)
        else:
            cwe_str = str(cwe).strip()
            if cwe_str:
                if not cwe_str.startswith("CWE-"):
                    cwe_str = f"CWE-{cwe_str}"
                found.append(cwe_str)

    # Try weaknesses array
    weaknesses = vuln.get("weaknesses", [])
    for weakness in weaknesses:
        if isinstance(weakness, dict):
            for desc in weakness.get("description", []):
                if isinstance(desc, dict):
                    value = desc.get("value", "").strip()
                    if value.startswith("CWE-") and value not in found:
                        found.append(value)

    containers = vuln.get("containers", {})
    if isinstance(containers, dict):
        cna = containers.get("cna", {})
        if isinstance(cna, dict):
            problem_types = cna.get("problemTypes", [])
            for problem in problem_types:
                if isinstance(problem, dict):
                    for desc in problem.get("descriptions", []):
                        if isinstance(desc, dict):
                            value = (desc.get("description") or desc.get("value") or "").strip()
                            if value.startswith("CWE-") and value not in found:
                                found.append(value)

    return found


def extract_references(vuln) -> List[Dict[str, Any]]:
    """Extract reference URLs and their metadata."""
    references = []
    refs = vuln.get("references") or []
    if not isinstance(refs, list):
        refs = [refs]
    containers = vuln.get("containers", {})
    if isinstance(containers, dict):
        cna = containers.get("cna", {})
        if isinstance(cna, dict):
            cna_refs = cna.get("references") or []
            if not isinstance(cna_refs, list):
                cna_refs = [cna_refs]
            refs = list(refs) + list(cna_refs)

    for ref in refs:
        if isinstance(ref, dict):
            references.append({
                "url": ref.get("url"),
                "source": ref.get("source"),
                "tags": ref.get("tags") or [],
            })
        elif isinstance(ref, str):
            # Simple URL string
            references.append({
                "url": ref,
                "source": None,
                "tags": [],
            })

    return references


def _get_nested(data: Dict[str, Any], *keys: str):
    current: Any = data
    for key in keys:
        if not isinstance(current, dict):
            return None
        current = current.get(key)
        if current is None:
            return None
    return current


def extract_cve_id(vuln: Dict[str, Any]) -> Optional[str]:
    """Extract the CVE ID from various vulnerability formats."""
    candidates = [
        ("id",),
        ("cve_id",),
        ("cve", "id"),
        ("cve", "CVE_data_meta", "ID"),
        ("cveMetadata", "cveId"),
        ("cveMetadata", "cveID"),
    ]
    for path in candidates:
        value = _get_nested(vuln, *path)
        if value:
            return str(value)
    return None


def _first_string(value: Any) -> Optional[str]:
    if isinstance(value, str) and value.strip():
        return value.strip()
    return None


def _parse_float(value: Any) -> Optional[float]:
    if value is None:
        return None
    try:
        return float(value)
    except (TypeError, ValueError):
        return None


def _normalize_cve_id(value: Optional[str]) -> Optional[str]:
    if not value:
        return None
    candidate = value.strip().upper()
    if _CVE_ID_RE.match(candidate):
        return candidate
    return None


def extract_source_identifier(vuln: Dict[str, Any]) -> Optional[str]:
    """Extract the best available source identifier for a vulnerability."""
    for key in ("sourceIdentifier", "assigner", "source", "originSource"):
        value = vuln.get(key)
        if isinstance(value, dict):
            for nested_key in ("name", "shortName", "source", "id"):
                nested_value = _first_string(value.get(nested_key))
                if nested_value:
                    return nested_value
        else:
            value = _first_string(value)
            if value:
                return value

    cve_metadata = vuln.get("cveMetadata", {})
    if isinstance(cve_metadata, dict):
        value = _first_string(cve_metadata.get("assignerShortName") or cve_metadata.get("assignerOrgId"))
        if value:
            return value

    metadata = vuln.get("metadata") or vuln.get("meta")
    if isinstance(metadata, dict):
        value = _first_string(metadata.get("source") or metadata.get("originSource"))
        if value:
            return value

    containers = vuln.get("containers", {})
    if isinstance(containers, dict):
        cna = containers.get("cna", {})
        if isinstance(cna, dict):
            provider = cna.get("providerMetadata", {})
            if isinstance(provider, dict):
                value = _first_string(provider.get("shortName") or provider.get("orgId"))
                if value:
                    return value

    return None


def extract_published_date(vuln: Dict[str, Any]) -> Optional[str]:
    """Extract the published date string from vulnerability data."""
    for key in ("published", "Published", "datePublished"):
        value = _first_string(vuln.get(key))
        if value:
            return value

    metadata = vuln.get("cveMetadata", {})
    if isinstance(metadata, dict):
        value = _first_string(metadata.get("datePublished"))
        if value:
            return value

    containers = vuln.get("containers", {})
    if isinstance(containers, dict):
        cna = containers.get("cna", {})
        if isinstance(cna, dict):
            value = _first_string(cna.get("datePublic") or cna.get("datePublished"))
            if value:
                return value

    return None


def extract_last_modified_date(vuln: Dict[str, Any]) -> Optional[str]:
    """Extract the last modified date string from vulnerability data."""
    for key in ("last-modified", "lastModified", "Modified", "modified", "dateUpdated", "updated"):
        value = _first_string(vuln.get(key))
        if value:
            return value

    metadata = vuln.get("cveMetadata", {})
    if isinstance(metadata, dict):
        value = _first_string(metadata.get("dateUpdated"))
        if value:
            return value

    containers = vuln.get("containers", {})
    if isinstance(containers, dict):
        cna = containers.get("cna", {})
        if isinstance(cna, dict):
            value = _first_string(cna.get("dateUpdated"))
            if value:
                return value

    return None


def is_kev(vuln) -> bool:
    """Check if vulnerability is in CISA Known Exploited Vulnerabilities catalog."""
    # Check for KEV data in various formats
    kev_data = vuln.get("kev", {})
    if isinstance(kev_data, dict) and kev_data:
        return True

    # Check for CISA fields
    cisa_fields = ("cisaExploitAdd", "cisaActionDue", "cisaRequiredAction", "cisaVulnerabilityName")
    if any(field in vuln for field in cisa_fields):
        return True

    # Check other field that might indicate KEV
    other = vuln.get("other", {})
    if isinstance(other, dict):
        content = other.get("content", {})
        if isinstance(content, dict) and content.get("type") == "kev":
            return True

    return False


def extract_kev_data(vuln) -> Dict[str, Any]:
    """Extract KEV-specific data (date added, required action, etc.)."""
    kev_info = {}

    # Try kev object
    kev_data = vuln.get("kev", {})
    if isinstance(kev_data, dict):
        kev_info = {
            "dateAdded": kev_data.get("dateAdded"),
            "dueDate": kev_data.get("dueDate"),
            "requiredAction": kev_data.get("requiredAction"),
            "vulnerabilityName": kev_data.get("vulnerabilityName"),
        }

    # Try other.content format
    other = vuln.get("other", {})
    if isinstance(other, dict):
        content = other.get("content", {})
        if isinstance(content, dict) and content.get("type") == "kev":
            kev_info = {
                "dateAdded": content.get("dateAdded"),
                "dueDate": content.get("dueDate"),
                "requiredAction": content.get("requiredAction"),
                "vulnerabilityName": content.get("vulnerabilityName"),
            }

    # Try CISA fields directly
    if not kev_info:
        kev_info = {
            "dateAdded": vuln.get("cisaExploitAdd"),
            "dueDate": vuln.get("cisaActionDue"),
            "requiredAction": vuln.get("cisaRequiredAction"),
            "vulnerabilityName": vuln.get("cisaVulnerabilityName"),
        }

    # Filter out None values
    return {k: v for k, v in kev_info.items() if v is not None}


def fetch_epss(session: requests.Session, vulnerability_id: str, insecure: bool,
               url_base: str = VULNERABILITY_LOOKUP_BASE) -> Dict[str, Optional[float]]:
    """Fetch EPSS data for a vulnerability ID."""
    normalized_id = _normalize_cve_id(vulnerability_id)
    if not normalized_id:
        return {"score": None, "percentile": None}

    cache_key = normalized_id
    cached = _EPSS_CACHE.get(cache_key)
    if cached is not None:
        return cached

    try:
        response = _do_get(session, f"/epss/{cache_key}", insecure, url_base=url_base)
        if response.status_code == 404:
            _EPSS_CACHE[cache_key] = {"score": None, "percentile": None}
            return _EPSS_CACHE[cache_key]
        response.raise_for_status()
        payload = response.json()
    except (requests.RequestException, ValueError):
        return {"score": None, "percentile": None}

    score = None
    percentile = None
    if isinstance(payload, dict):
        data = payload.get("data")
        if isinstance(data, list) and data:
            entry = data[0]
            if isinstance(entry, dict):
                score = _parse_float(entry.get("epss"))
                percentile = _parse_float(entry.get("percentile"))
        elif "epss" in payload:
            score = _parse_float(payload.get("epss"))
            percentile = _parse_float(payload.get("percentile"))

    result = {"score": score, "percentile": percentile}
    _EPSS_CACHE[cache_key] = result
    return result


def fetch_nvd_cvss(session: requests.Session, vulnerability_id: str, insecure: bool) -> Dict[str, Any]:
    """Fetch CVSS metrics from NVD for a vulnerability ID."""
    normalized_id = _normalize_cve_id(vulnerability_id)
    if not normalized_id:
        return _empty_cvss_metrics()

    cache_key = normalized_id
    cached = _NVD_CACHE.get(cache_key)
    if cached is not None:
        return cached

    try:
        extra_headers = {"apiKey": NVD_API_KEY} if NVD_API_KEY else None
        response = _request_json(
            session,
            NVD_API_BASE,
            insecure,
            params={"cveId": cache_key},
            extra_headers=extra_headers,
        )
        if response.status_code == 404:
            _NVD_CACHE[cache_key] = _empty_cvss_metrics()
            return _NVD_CACHE[cache_key]
        response.raise_for_status()
        payload = response.json()
    except (requests.RequestException, ValueError):
        return _empty_cvss_metrics()

    metrics = None
    if isinstance(payload, dict):
        vulnerabilities = payload.get("vulnerabilities")
        if isinstance(vulnerabilities, list) and vulnerabilities:
            entry = vulnerabilities[0]
            if isinstance(entry, dict):
                cve = entry.get("cve")
                if isinstance(cve, dict):
                    metrics = cve.get("metrics")

    normalized = _pick_nvd_cvss(metrics) if isinstance(metrics, dict) else None
    result = normalized or _empty_cvss_metrics()
    _NVD_CACHE[cache_key] = result
    return result


def fetch_cisa_kev_data(
    session: requests.Session,
    insecure: bool,
    url_base: str = VULNERABILITY_LOOKUP_BASE,
    ttl_seconds: int = 6 * 60 * 60,
) -> Dict[str, Dict[str, Any]]:
    """Fetch and cache the CISA KEV catalog data."""
    now = time.time()
    cached = _KEV_CACHE.get("data", {})
    if cached and _KEV_CACHE.get("expires_at", 0) > now:
        return cached

    kev_map: Dict[str, Dict[str, Any]] = {}
    page = 1
    per_page = 2000

    while True:
        try:
            response = _do_get(
                session,
                "/cisa_kev/",
                insecure,
                url_base=url_base,
                params={"page": page, "per_page": per_page},
            )
            response.raise_for_status()
            payload = response.json()
        except (requests.RequestException, ValueError):
            break

        entries = []
        metadata = {}
        if isinstance(payload, dict):
            entries = payload.get("data", [])
            metadata = payload.get("metadata", {}) or {}
        elif isinstance(payload, list):
            entries = payload

        if isinstance(entries, list):
            for entry in entries:
                if not isinstance(entry, dict):
                    continue
                cve_id = entry.get("cveID") or entry.get("CVE") or entry.get("cve")
                if not cve_id:
                    continue
                kev_map[cve_id.upper()] = {
                    "dateAdded": entry.get("dateAdded") or entry.get("dateReported"),
                    "dueDate": entry.get("dueDate"),
                    "requiredAction": entry.get("requiredAction"),
                    "vulnerabilityName": entry.get("vulnerabilityName") or entry.get("shortDescription"),
                    "knownRansomwareCampaignUse": entry.get("knownRansomwareCampaignUse"),
                    "notes": entry.get("notes"),
                    "vendorProject": entry.get("vendorProject"),
                    "product": entry.get("product"),
                }

        total_pages = metadata.get("total_pages")
        if not total_pages:
            count = metadata.get("count")
            per_page_meta = metadata.get("per_page") or per_page
            if isinstance(count, int) and isinstance(per_page_meta, int) and per_page_meta:
                total_pages = max(1, (count + per_page_meta - 1) // per_page_meta)
            else:
                total_pages = 1

        if page >= total_pages:
            break
        page += 1

    _KEV_CACHE["data"] = kev_map
    _KEV_CACHE["expires_at"] = now + ttl_seconds
    return kev_map


def _extract_vuln_date(vuln: Dict[str, Any]):
    """
    Extract the last modified/updated date from vulnerability data.

    Different vulnerability sources use different date field names.
    Returns the parsed datetime or None if no date found.
    """
    # Primary date fields to check (in priority order)
    date_fields = [
        "lastModified",      # NVD format
        "last-modified",     # Alternative format
        "modified",          # Generic
        "dateUpdated",       # CVE format
        "updated",           # Generic
        "datePublished",     # Fallback to published date
        "published",         # Generic published
    ]

    # First try direct fields
    for field in date_fields:
        date_val = vuln.get(field)
        if date_val:
            parsed = _safe_parse_date(date_val)
            if parsed:
                return parsed

    # Check cveMetadata for cvelistv5 format
    cve_metadata = vuln.get("cveMetadata", {})
    if isinstance(cve_metadata, dict):
        date_val = cve_metadata.get("dateUpdated") or cve_metadata.get("datePublished")
        if date_val:
            parsed = _safe_parse_date(date_val)
            if parsed:
                return parsed

    # Check containers.cna for CVE 5.0 format
    containers = vuln.get("containers", {})
    if isinstance(containers, dict):
        cna = containers.get("cna", {})
        if isinstance(cna, dict):
            date_val = cna.get("dateUpdated") or cna.get("datePublished")
            if date_val:
                parsed = _safe_parse_date(date_val)
                if parsed:
                    return parsed

    return None


def _safe_parse_date(date_val: Any):
    try:
        return parse_iso(date_val)
    except (TypeError, ValueError):
        return None


def fetch_for_cpe(
    session: requests.Session,
    cpe: str,
    since,
    until,
    insecure: bool,
    sources: Optional[List[str]] = None,
    page: int = 1,
    per_page: int = 100,
    fetch_all_pages: bool = True,
) -> List[dict]:
    """
    Fetch vulnerabilities for a given CPE from Vulnerability-Lookup API.

    Args:
        session: Requests session with retry configuration
        cpe: CPE 2.3 string to search for
        since: Start datetime for filtering (client-side)
        until: End datetime for filtering (client-side)
        insecure: Skip TLS verification if True
        page: Page number for pagination (default: 1)
        per_page: Results per page, max 100 (default: 100)
        fetch_all_pages: If True, fetch all pages; if False, fetch only requested page

    Returns:
        List of vulnerability dictionaries filtered by date range

    Note: Uses the /vulnerability/cpesearch/{cpe} endpoint.
    Time filtering is done client-side since the API doesn't support date ranges.
    """
    # URL-encode the CPE for the API call
    cpe_encoded = urllib.parse.quote(cpe, safe='')
    path = f"/vulnerability/cpesearch/{cpe_encoded}"

    all_vulnerabilities = []
    source_filters = [s for s in (sources or []) if s]
    if not source_filters:
        source_filters = [None]

    for source in source_filters:
        current_page = page
        while True:
            params = {
                "page": current_page,
                "per_page": min(per_page, 100),  # API max is 100
            }
            if source:
                params["source"] = source

            try:
                response = _do_get(session, path, insecure, params=params)
                response.raise_for_status()
                data = response.json()
            except requests.HTTPError as exc:
                # If 404, it might mean no vulnerabilities found - return empty list
                if exc.response and exc.response.status_code == 404:
                    break
                logger.error(f"HTTP error fetching vulnerabilities for {cpe}: {exc}")
                raise
            except (requests.RequestException, ValueError) as exc:
                # Network error or invalid JSON - log and return empty list
                logger.warning(f"Error fetching vulnerabilities for {cpe}: {exc}")
                break

            # Handle different response formats
            # New API returns paginated response with 'data' key
            if isinstance(data, dict):
                if "data" in data:
                    # Paginated response format
                    vulnerabilities = data.get("data", [])
                    metadata = data.get("metadata", {})
                else:
                    # Legacy response formats
                    vulnerabilities = data.get("results", data.get("vulnerabilities", []))
                    metadata = {}
                    if not vulnerabilities:
                        for key, value in data.items():
                            if key == "metadata":
                                if isinstance(value, dict):
                                    metadata = value
                                continue
                            if isinstance(value, list):
                                vulnerabilities.extend(value)
            elif isinstance(data, list):
                # Direct list response
                vulnerabilities = data
                metadata = {}
            else:
                vulnerabilities = []
                metadata = {}

            if source and isinstance(vulnerabilities, list):
                for vuln in vulnerabilities:
                    if isinstance(vuln, dict) and not vuln.get("source"):
                        vuln["source"] = source

            all_vulnerabilities.extend(vulnerabilities)

            # Check if we should fetch more pages
            if not fetch_all_pages:
                break

            total_pages = metadata.get("total_pages", 1)
            if current_page >= total_pages:
                break

            current_page += 1

    # Filter by date range (client-side filtering)
    filtered = []
    for vuln in all_vulnerabilities:
        if not isinstance(vuln, dict):
            continue

        # Get last modified date using comprehensive extraction
        mod_date = _extract_vuln_date(vuln)

        if mod_date:
            # Include if modified within our time window
            if since <= mod_date <= until:
                filtered.append(vuln)
        else:
            # If no date found, include the vulnerability to be safe
            filtered.append(vuln)

    return filtered

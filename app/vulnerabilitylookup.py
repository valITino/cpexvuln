from typing import List, Optional, Dict, Any
import logging
import urllib.parse
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import urllib3

from .config import VULNERABILITY_LOOKUP_BASE, DEFAULT_TIMEOUT
from .utils import parse_iso

logger = logging.getLogger(__name__)

UA = "CPE-Watch/2.0 (+vulnerability-lookup)"


def build_session(https_proxy=None, http_proxy=None, ca_bundle=None, insecure=False, timeout=DEFAULT_TIMEOUT):
    """Build a requests session with retry logic and proxy support."""
    session = requests.Session()
    retry = Retry(
        total=4,
        backoff_factor=1.0,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=("GET",),
        raise_on_status=False,
    )
    session.mount("https://", HTTPAdapter(max_retries=retry))
    session.mount("http://", HTTPAdapter(max_retries=retry))

    proxies: Dict[str, str] = {}
    if http_proxy:
        proxies["http"] = http_proxy
    if https_proxy:
        proxies["https"] = https_proxy
    if proxies:
        session.proxies.update(proxies)

    if ca_bundle:
        session.verify = ca_bundle
    session.timeout = timeout

    if insecure:
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    return session


def _do_get(
    session: requests.Session,
    path: str,
    insecure: bool,
    url_base: str = VULNERABILITY_LOOKUP_BASE,
    params: Optional[Dict[str, Any]] = None,
):
    """Execute GET request to Vulnerability-Lookup API."""
    headers = {
        "User-Agent": UA,
        "Accept": "application/json",
    }
    verify = False if insecure else getattr(session, "verify", True)
    timeout = getattr(session, "timeout", DEFAULT_TIMEOUT)
    full_url = f"{url_base}{path}"
    return session.get(full_url, headers=headers, verify=verify, timeout=timeout, params=params)


def _severity_from_score(score: Optional[float]) -> str:
    """Convert CVSS score to severity level."""
    if score is None:
        return "None"
    try:
        value = float(score)
    except Exception:
        return "None"
    if value >= 9.0:
        return "Critical"
    if value >= 7.0:
        return "High"
    if value >= 4.0:
        return "Medium"
    if value > 0.0:
        return "Low"
    return "None"


def _pick_cvss(vuln_data: Dict[str, Any]) -> Dict[str, Any]:
    """Extract best available CVSS metrics (prioritize v4 > v3.1 > v3.0 > v2)."""
    # Vulnerability-Lookup stores CVSS in different formats
    # Check for cvss-metrics array first
    cvss_metrics = vuln_data.get("cvss-metrics", [])

    # Priority order for CVSS versions
    for version_key in ("cvssV4_0", "cvssV3_1", "cvssV3_0", "cvssV2_0"):
        for metric in cvss_metrics:
            if version_key in metric:
                data = metric[version_key]
                score = data.get("baseScore")
                severity = data.get("baseSeverity") or _severity_from_score(score)
                return {
                    "version": data.get("version"),
                    "vector": data.get("vectorString"),
                    "baseScore": score,
                    "baseSeverity": severity,
                }

    # Fallback: try legacy cvss field
    cvss = vuln_data.get("cvss")
    if cvss:
        return {
            "version": "2.0",
            "vector": None,
            "baseScore": cvss,
            "baseSeverity": _severity_from_score(cvss),
        }

    return {"version": None, "vector": None, "baseScore": None, "baseSeverity": "None"}


def extract_metrics(vuln) -> Dict[str, Any]:
    """Extract CVSS metrics from vulnerability data."""
    return _pick_cvss(vuln)


def extract_epss(vuln) -> Dict[str, Any]:
    """Extract EPSS (Exploit Prediction Scoring System) data."""
    epss_data = vuln.get("epss", {})
    if isinstance(epss_data, dict):
        return {
            "score": epss_data.get("epss"),  # Probability of exploitation (0-1)
            "percentile": epss_data.get("percentile"),  # Percentile ranking
        }
    return {"score": None, "percentile": None}


def extract_description(vuln) -> str:
    """Extract vulnerability description."""
    # Try summary field first
    summary = vuln.get("summary", "").strip()
    if summary:
        return summary

    # Try descriptions array (similar to NVD format)
    descriptions = vuln.get("descriptions", [])
    for entry in descriptions:
        if isinstance(entry, dict):
            if entry.get("lang", "").lower() == "en":
                value = entry.get("value", "").strip()
                if value:
                    return value

    # Fallback to any description
    for entry in descriptions:
        if isinstance(entry, dict):
            value = entry.get("value", "").strip()
            if value:
                return value

    return ""


def extract_cwes(vuln) -> List[str]:
    """Extract CWE (Common Weakness Enumeration) identifiers."""
    found: List[str] = []

    # Try cwe field (may be a list or single value)
    cwe = vuln.get("cwe")
    if cwe:
        if isinstance(cwe, list):
            for item in cwe:
                cwe_str = str(item).strip()
                if cwe_str and cwe_str not in found:
                    if not cwe_str.startswith("CWE-"):
                        cwe_str = f"CWE-{cwe_str}"
                    found.append(cwe_str)
        else:
            cwe_str = str(cwe).strip()
            if cwe_str:
                if not cwe_str.startswith("CWE-"):
                    cwe_str = f"CWE-{cwe_str}"
                found.append(cwe_str)

    # Try weaknesses array
    weaknesses = vuln.get("weaknesses", [])
    for weakness in weaknesses:
        if isinstance(weakness, dict):
            for desc in weakness.get("description", []):
                if isinstance(desc, dict):
                    value = desc.get("value", "").strip()
                    if value.startswith("CWE-") and value not in found:
                        found.append(value)

    return found


def extract_references(vuln) -> List[Dict[str, Any]]:
    """Extract reference URLs and their metadata."""
    references = []
    refs = vuln.get("references", [])

    for ref in refs:
        if isinstance(ref, dict):
            references.append({
                "url": ref.get("url"),
                "source": ref.get("source"),
                "tags": ref.get("tags") or [],
            })
        elif isinstance(ref, str):
            # Simple URL string
            references.append({
                "url": ref,
                "source": None,
                "tags": [],
            })

    return references


def is_kev(vuln) -> bool:
    """Check if vulnerability is in CISA Known Exploited Vulnerabilities catalog."""
    # Check for KEV data in various formats
    kev_data = vuln.get("kev", {})
    if isinstance(kev_data, dict) and kev_data:
        return True

    # Check for CISA fields
    cisa_fields = ("cisaExploitAdd", "cisaActionDue", "cisaRequiredAction", "cisaVulnerabilityName")
    if any(field in vuln for field in cisa_fields):
        return True

    # Check other field that might indicate KEV
    other = vuln.get("other", {})
    if isinstance(other, dict):
        content = other.get("content", {})
        if isinstance(content, dict) and content.get("type") == "kev":
            return True

    return False


def extract_kev_data(vuln) -> Dict[str, Any]:
    """Extract KEV-specific data (date added, required action, etc.)."""
    kev_info = {}

    # Try kev object
    kev_data = vuln.get("kev", {})
    if isinstance(kev_data, dict):
        kev_info = {
            "dateAdded": kev_data.get("dateAdded"),
            "dueDate": kev_data.get("dueDate"),
            "requiredAction": kev_data.get("requiredAction"),
            "vulnerabilityName": kev_data.get("vulnerabilityName"),
        }

    # Try other.content format
    other = vuln.get("other", {})
    if isinstance(other, dict):
        content = other.get("content", {})
        if isinstance(content, dict) and content.get("type") == "kev":
            kev_info = {
                "dateAdded": content.get("dateAdded"),
                "dueDate": content.get("dueDate"),
                "requiredAction": content.get("requiredAction"),
                "vulnerabilityName": content.get("vulnerabilityName"),
            }

    # Try CISA fields directly
    if not kev_info:
        kev_info = {
            "dateAdded": vuln.get("cisaExploitAdd"),
            "dueDate": vuln.get("cisaActionDue"),
            "requiredAction": vuln.get("cisaRequiredAction"),
            "vulnerabilityName": vuln.get("cisaVulnerabilityName"),
        }

    # Filter out None values
    return {k: v for k, v in kev_info.items() if v is not None}


def _extract_vuln_date(vuln: Dict[str, Any]):
    """
    Extract the last modified/updated date from vulnerability data.

    Different vulnerability sources use different date field names.
    Returns the parsed datetime or None if no date found.
    """
    # Primary date fields to check (in priority order)
    date_fields = [
        "lastModified",      # NVD format
        "last-modified",     # Alternative format
        "modified",          # Generic
        "dateUpdated",       # CVE format
        "updated",           # Generic
        "datePublished",     # Fallback to published date
        "published",         # Generic published
    ]

    # First try direct fields
    for field in date_fields:
        date_val = vuln.get(field)
        if date_val:
            try:
                return parse_iso(date_val)
            except Exception:
                continue

    # Check cveMetadata for cvelistv5 format
    cve_metadata = vuln.get("cveMetadata", {})
    if isinstance(cve_metadata, dict):
        date_val = cve_metadata.get("dateUpdated") or cve_metadata.get("datePublished")
        if date_val:
            try:
                return parse_iso(date_val)
            except Exception:
                pass

    # Check containers.cna for CVE 5.0 format
    containers = vuln.get("containers", {})
    if isinstance(containers, dict):
        cna = containers.get("cna", {})
        if isinstance(cna, dict):
            date_val = cna.get("dateUpdated") or cna.get("datePublished")
            if date_val:
                try:
                    return parse_iso(date_val)
                except Exception:
                    pass

    return None


def fetch_for_cpe(
    session: requests.Session,
    cpe: str,
    since,
    until,
    insecure: bool,
    page: int = 1,
    per_page: int = 100,
    fetch_all_pages: bool = True,
) -> List[dict]:
    """
    Fetch vulnerabilities for a given CPE from Vulnerability-Lookup API.

    Args:
        session: Requests session with retry configuration
        cpe: CPE 2.3 string to search for
        since: Start datetime for filtering (client-side)
        until: End datetime for filtering (client-side)
        insecure: Skip TLS verification if True
        page: Page number for pagination (default: 1)
        per_page: Results per page, max 100 (default: 100)
        fetch_all_pages: If True, fetch all pages; if False, fetch only requested page

    Returns:
        List of vulnerability dictionaries filtered by date range

    Note: Uses the /api/vulnerability/cpesearch/{cpe} endpoint.
    Time filtering is done client-side since the API doesn't support date ranges.
    """
    # URL-encode the CPE for the API call
    cpe_encoded = urllib.parse.quote(cpe, safe='')
    path = f"/api/vulnerability/cpesearch/{cpe_encoded}"

    all_vulnerabilities = []
    current_page = page

    while True:
        params = {
            "page": current_page,
            "per_page": min(per_page, 100),  # API max is 100
        }

        try:
            response = _do_get(session, path, insecure, params=params)
            response.raise_for_status()
            data = response.json()
        except requests.HTTPError as exc:
            # If 404, it might mean no vulnerabilities found - return empty list
            if exc.response and exc.response.status_code == 404:
                return []
            logger.error(f"HTTP error fetching vulnerabilities for {cpe}: {exc}")
            raise
        except (requests.RequestException, ValueError) as exc:
            # Network error or invalid JSON - log and return empty list
            logger.warning(f"Error fetching vulnerabilities for {cpe}: {exc}")
            return []

        # Handle different response formats
        # New API returns paginated response with 'data' key
        if isinstance(data, dict):
            if "data" in data:
                # Paginated response format
                vulnerabilities = data.get("data", [])
                metadata = data.get("metadata", {})
            else:
                # Legacy response formats
                vulnerabilities = data.get("results", data.get("vulnerabilities", []))
                metadata = {}
        elif isinstance(data, list):
            # Direct list response
            vulnerabilities = data
            metadata = {}
        else:
            vulnerabilities = []
            metadata = {}

        all_vulnerabilities.extend(vulnerabilities)

        # Check if we should fetch more pages
        if not fetch_all_pages:
            break

        total_pages = metadata.get("total_pages", 1)
        if current_page >= total_pages:
            break

        current_page += 1

    # Filter by date range (client-side filtering)
    filtered = []
    for vuln in all_vulnerabilities:
        if not isinstance(vuln, dict):
            continue

        # Get last modified date using comprehensive extraction
        mod_date = _extract_vuln_date(vuln)

        if mod_date:
            # Include if modified within our time window
            if since <= mod_date <= until:
                filtered.append(vuln)
        else:
            # If no date found, include the vulnerability to be safe
            filtered.append(vuln)

    return filtered

"""
Vulnerability-Lookup API client with comprehensive logging and error handling.

API Documentation: https://vulnerability.circl.lu/api/
Endpoints used:
  - GET /api/cve/{cve_id} - Get specific CVE
  - GET /api/search/{vendor}/{product} - Search by vendor/product
  - GET /api/browse - Browse recent vulnerabilities
  - GET /api/last - Get latest vulnerabilities
"""

from typing import List, Optional, Dict, Any
import logging
import urllib.parse
import time
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import urllib3

from .config import VULNERABILITY_LOOKUP_BASE, DEFAULT_TIMEOUT

logger = logging.getLogger(__name__)

UA = "CPE-Watch/2.0 (+vulnerability-lookup)"


def build_session(
    https_proxy: Optional[str] = None,
    http_proxy: Optional[str] = None,
    ca_bundle: Optional[str] = None,
    insecure: bool = False,
    timeout: int = DEFAULT_TIMEOUT
) -> requests.Session:
    """
    Build a requests session with retry logic, proxy support, and certificate configuration.

    Args:
        https_proxy: HTTPS proxy URL (e.g., https://user:pass@host:port)
        http_proxy: HTTP proxy URL (e.g., http://user:pass@host:port)
        ca_bundle: Path to custom CA bundle (PEM file)
        insecure: If True, skip TLS verification (not recommended)
        timeout: Request timeout in seconds

    Returns:
        Configured requests.Session object
    """
    session = requests.Session()

    # Configure retry strategy
    retry = Retry(
        total=4,
        backoff_factor=1.0,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=("GET",),
        raise_on_status=False,
    )
    session.mount("https://", HTTPAdapter(max_retries=retry))
    session.mount("http://", HTTPAdapter(max_retries=retry))

    # Configure proxies
    proxies: Dict[str, str] = {}
    if http_proxy:
        proxies["http"] = http_proxy
        logger.debug(f"HTTP proxy configured: {_mask_proxy_credentials(http_proxy)}")
    if https_proxy:
        proxies["https"] = https_proxy
        logger.debug(f"HTTPS proxy configured: {_mask_proxy_credentials(https_proxy)}")
    if proxies:
        session.proxies.update(proxies)

    # Configure TLS/SSL
    if ca_bundle:
        session.verify = ca_bundle
        logger.info(f"Using custom CA bundle: {ca_bundle}")
    elif insecure:
        session.verify = False
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        logger.warning("TLS verification DISABLED - this is insecure!")
    else:
        session.verify = True

    session.timeout = timeout
    logger.debug(f"Session configured with timeout={timeout}s, verify={session.verify}")

    return session


def _mask_proxy_credentials(proxy_url: str) -> str:
    """Mask credentials in proxy URL for safe logging."""
    try:
        parsed = urllib.parse.urlparse(proxy_url)
        if parsed.password:
            masked = parsed._replace(netloc=f"{parsed.username}:****@{parsed.hostname}:{parsed.port}")
            return masked.geturl()
    except Exception:
        pass
    return proxy_url


def _do_get(
    session: requests.Session,
    path: str,
    insecure: bool,
    url_base: str = VULNERABILITY_LOOKUP_BASE,
    params: Optional[Dict[str, Any]] = None,
) -> requests.Response:
    """
    Execute GET request to Vulnerability-Lookup API with logging.

    Args:
        session: Configured requests session
        path: API endpoint path
        insecure: Override TLS verification
        url_base: Base URL for API
        params: Query parameters

    Returns:
        Response object

    Raises:
        requests.RequestException: On network errors
    """
    headers = {
        "User-Agent": UA,
        "Accept": "application/json",
    }
    verify = False if insecure else getattr(session, "verify", True)
    timeout = getattr(session, "timeout", DEFAULT_TIMEOUT)
    full_url = f"{url_base}{path}"

    logger.debug(f"API Request: GET {full_url} params={params}")
    start_time = time.time()

    try:
        response = session.get(full_url, headers=headers, verify=verify, timeout=timeout, params=params)
        elapsed = time.time() - start_time
        logger.debug(f"API Response: {response.status_code} in {elapsed:.2f}s ({len(response.content)} bytes)")
        return response
    except requests.exceptions.SSLError as e:
        logger.error(f"SSL/TLS Error connecting to {full_url}: {e}")
        logger.error("Hint: Check your CA bundle (--ca-bundle) or use --insecure for testing")
        raise
    except requests.exceptions.ProxyError as e:
        logger.error(f"Proxy Error: {e}")
        logger.error("Hint: Check your proxy settings (--http-proxy, --https-proxy)")
        raise
    except requests.exceptions.ConnectionError as e:
        logger.error(f"Connection Error to {full_url}: {e}")
        raise
    except requests.exceptions.Timeout as e:
        logger.error(f"Request Timeout after {timeout}s to {full_url}")
        raise


def _severity_from_score(score: Optional[float]) -> str:
    """Convert CVSS score to severity level."""
    if score is None:
        return "None"
    try:
        value = float(score)
    except Exception:
        return "None"
    if value >= 9.0:
        return "Critical"
    if value >= 7.0:
        return "High"
    if value >= 4.0:
        return "Medium"
    if value > 0.0:
        return "Low"
    return "None"


def _pick_cvss(vuln_data: Dict[str, Any]) -> Dict[str, Any]:
    """Extract best available CVSS metrics (prioritize v4 > v3.1 > v3.0 > v2)."""
    # Vulnerability-Lookup stores CVSS in different formats
    # Check for cvss-metrics array first
    cvss_metrics = vuln_data.get("cvss-metrics", [])

    # Priority order for CVSS versions
    for version_key in ("cvssV4_0", "cvssV3_1", "cvssV3_0", "cvssV2_0"):
        for metric in cvss_metrics:
            if version_key in metric:
                data = metric[version_key]
                score = data.get("baseScore")
                severity = data.get("baseSeverity") or _severity_from_score(score)
                return {
                    "version": data.get("version"),
                    "vector": data.get("vectorString"),
                    "baseScore": score,
                    "baseSeverity": severity,
                }

    # Try cvss3 field (common in many APIs)
    cvss3 = vuln_data.get("cvss3") or vuln_data.get("cvssV3")
    if cvss3:
        if isinstance(cvss3, dict):
            score = cvss3.get("baseScore")
        else:
            score = cvss3
        return {
            "version": "3.x",
            "vector": cvss3.get("vectorString") if isinstance(cvss3, dict) else None,
            "baseScore": score,
            "baseSeverity": _severity_from_score(score),
        }

    # Fallback: try legacy cvss field
    cvss = vuln_data.get("cvss") or vuln_data.get("cvss2")
    if cvss:
        if isinstance(cvss, dict):
            score = cvss.get("baseScore")
        else:
            score = cvss
        return {
            "version": "2.0",
            "vector": None,
            "baseScore": score,
            "baseSeverity": _severity_from_score(score),
        }

    return {"version": None, "vector": None, "baseScore": None, "baseSeverity": "None"}


def extract_metrics(vuln) -> Dict[str, Any]:
    """Extract CVSS metrics from vulnerability data."""
    return _pick_cvss(vuln)


def extract_epss(vuln) -> Dict[str, Any]:
    """Extract EPSS (Exploit Prediction Scoring System) data."""
    epss_data = vuln.get("epss", {})
    if isinstance(epss_data, dict):
        return {
            "score": epss_data.get("epss"),  # Probability of exploitation (0-1)
            "percentile": epss_data.get("percentile"),  # Percentile ranking
        }
    return {"score": None, "percentile": None}


def extract_description(vuln) -> str:
    """Extract vulnerability description."""
    # Try summary field first (Vulnerability-Lookup format)
    summary = vuln.get("summary", "").strip()
    if summary:
        return summary

    # Try descriptions array (similar to NVD format)
    descriptions = vuln.get("descriptions", [])
    for entry in descriptions:
        if isinstance(entry, dict):
            if entry.get("lang", "").lower() == "en":
                value = entry.get("value", "").strip()
                if value:
                    return value

    # Fallback to any description
    for entry in descriptions:
        if isinstance(entry, dict):
            value = entry.get("value", "").strip()
            if value:
                return value

    return ""


def extract_cwes(vuln) -> List[str]:
    """Extract CWE (Common Weakness Enumeration) identifiers."""
    found: List[str] = []

    # Try cwe field (may be a list or single value)
    cwe = vuln.get("cwe")
    if cwe:
        if isinstance(cwe, list):
            for item in cwe:
                cwe_str = str(item).strip()
                if cwe_str and cwe_str not in found:
                    if not cwe_str.startswith("CWE-"):
                        cwe_str = f"CWE-{cwe_str}"
                    found.append(cwe_str)
        else:
            cwe_str = str(cwe).strip()
            if cwe_str:
                if not cwe_str.startswith("CWE-"):
                    cwe_str = f"CWE-{cwe_str}"
                found.append(cwe_str)

    # Try weaknesses array
    weaknesses = vuln.get("weaknesses", [])
    for weakness in weaknesses:
        if isinstance(weakness, dict):
            for desc in weakness.get("description", []):
                if isinstance(desc, dict):
                    value = desc.get("value", "").strip()
                    if value.startswith("CWE-") and value not in found:
                        found.append(value)

    return found


def extract_references(vuln) -> List[Dict[str, Any]]:
    """Extract reference URLs and their metadata."""
    references = []
    refs = vuln.get("references", [])

    for ref in refs:
        if isinstance(ref, dict):
            references.append({
                "url": ref.get("url"),
                "source": ref.get("source"),
                "tags": ref.get("tags") or [],
            })
        elif isinstance(ref, str):
            # Simple URL string
            references.append({
                "url": ref,
                "source": None,
                "tags": [],
            })

    return references


def is_kev(vuln) -> bool:
    """Check if vulnerability is in CISA Known Exploited Vulnerabilities catalog."""
    # Check for KEV data in various formats
    kev_data = vuln.get("kev", {})
    if isinstance(kev_data, dict) and kev_data:
        return True

    # Check for CISA fields
    cisa_fields = ("cisaExploitAdd", "cisaActionDue", "cisaRequiredAction", "cisaVulnerabilityName")
    if any(field in vuln for field in cisa_fields):
        return True

    # Check other field that might indicate KEV
    other = vuln.get("other", {})
    if isinstance(other, dict):
        content = other.get("content", {})
        if isinstance(content, dict) and content.get("type") == "kev":
            return True

    return False


def extract_kev_data(vuln) -> Dict[str, Any]:
    """Extract KEV-specific data (date added, required action, etc.)."""
    kev_info = {}

    # Try kev object
    kev_data = vuln.get("kev", {})
    if isinstance(kev_data, dict):
        kev_info = {
            "dateAdded": kev_data.get("dateAdded"),
            "dueDate": kev_data.get("dueDate"),
            "requiredAction": kev_data.get("requiredAction"),
            "vulnerabilityName": kev_data.get("vulnerabilityName"),
        }

    # Try other.content format
    other = vuln.get("other", {})
    if isinstance(other, dict):
        content = other.get("content", {})
        if isinstance(content, dict) and content.get("type") == "kev":
            kev_info = {
                "dateAdded": content.get("dateAdded"),
                "dueDate": content.get("dueDate"),
                "requiredAction": content.get("requiredAction"),
                "vulnerabilityName": content.get("vulnerabilityName"),
            }

    # Try CISA fields directly
    if not kev_info:
        kev_info = {
            "dateAdded": vuln.get("cisaExploitAdd"),
            "dueDate": vuln.get("cisaActionDue"),
            "requiredAction": vuln.get("cisaRequiredAction"),
            "vulnerabilityName": vuln.get("cisaVulnerabilityName"),
        }

    # Filter out None values
    return {k: v for k, v in kev_info.items() if v is not None}


def _extract_vuln_date(vuln: Dict[str, Any]):
    """
    Extract the last modified/updated date from vulnerability data.

    Different vulnerability sources use different date field names.
    Returns the parsed datetime or None if no date found.
    """
    from .utils import parse_iso

    # Primary date fields to check (in priority order)
    date_fields = [
        "lastModified",      # NVD format
        "last-modified",     # Alternative format
        "Modified",          # CVE format
        "modified",          # Generic
        "dateUpdated",       # CVE format
        "updated",           # Generic
        "datePublished",     # Fallback to published date
        "Published",         # CVE format
        "published",         # Generic published
    ]

    # First try direct fields
    for field in date_fields:
        date_val = vuln.get(field)
        if date_val:
            try:
                return parse_iso(date_val)
            except Exception:
                continue

    # Check cveMetadata for cvelistv5 format
    cve_metadata = vuln.get("cveMetadata", {})
    if isinstance(cve_metadata, dict):
        date_val = cve_metadata.get("dateUpdated") or cve_metadata.get("datePublished")
        if date_val:
            try:
                return parse_iso(date_val)
            except Exception:
                pass

    # Check containers.cna for CVE 5.0 format
    containers = vuln.get("containers", {})
    if isinstance(containers, dict):
        cna = containers.get("cna", {})
        if isinstance(cna, dict):
            date_val = cna.get("dateUpdated") or cna.get("datePublished")
            if date_val:
                try:
                    return parse_iso(date_val)
                except Exception:
                    pass

    return None


def _parse_cpe_components(cpe: str) -> Dict[str, str]:
    """
    Parse CPE 2.3 string into vendor and product components.

    CPE 2.3 format: cpe:2.3:part:vendor:product:version:update:edition:language:sw_edition:target_sw:target_hw:other
    """
    components = {"vendor": "*", "product": "*", "version": "*"}

    if not cpe:
        return components

    parts = cpe.split(":")
    if len(parts) >= 4:
        components["vendor"] = parts[3] if parts[3] != "*" else "*"
    if len(parts) >= 5:
        components["product"] = parts[4] if parts[4] != "*" else "*"
    if len(parts) >= 6:
        components["version"] = parts[5] if parts[5] != "*" else "*"

    return components


def fetch_for_cpe(
    session: requests.Session,
    cpe: str,
    since,
    until,
    insecure: bool,
    page: int = 1,
    per_page: int = 100,
    fetch_all_pages: bool = True,
) -> List[dict]:
    """
    Fetch vulnerabilities for a given CPE from Vulnerability-Lookup API.

    The Vulnerability-Lookup API supports several search methods:
    1. /api/search/{vendor}/{product} - Search by vendor/product
    2. /api/cve/{id} - Get specific CVE
    3. /api/browse - Browse vulnerabilities

    Args:
        session: Requests session with retry configuration
        cpe: CPE 2.3 string to search for
        since: Start datetime for filtering (client-side)
        until: End datetime for filtering (client-side)
        insecure: Skip TLS verification if True
        page: Page number for pagination (default: 1)
        per_page: Results per page, max 100 (default: 100)
        fetch_all_pages: If True, fetch all pages; if False, fetch only requested page

    Returns:
        List of vulnerability dictionaries filtered by date range
    """
    logger.info(f"Fetching vulnerabilities for CPE: {cpe}")
    logger.debug(f"Time window: {since} to {until}")

    # Parse CPE to extract vendor/product for API search
    cpe_parts = _parse_cpe_components(cpe)
    vendor = cpe_parts["vendor"]
    product = cpe_parts["product"]

    if vendor == "*" or product == "*":
        logger.warning(f"CPE has wildcard vendor/product: {cpe} - this may return broad results")

    all_vulnerabilities = []

    # Try multiple API endpoints in order of preference
    endpoints_to_try = []

    # Primary: Search by vendor/product
    if vendor != "*" and product != "*":
        endpoints_to_try.append(f"/api/search/{vendor}/{product}")

    # Fallback: Try CPE-based search endpoints
    cpe_encoded = urllib.parse.quote(cpe, safe='')
    endpoints_to_try.append(f"/api/cpe2.3/{cpe_encoded}")
    endpoints_to_try.append(f"/api/search/{cpe_encoded}")

    # Alternative API endpoints that might exist
    if vendor != "*":
        endpoints_to_try.append(f"/api/browse/vendor/{vendor}")

    last_error = None

    for endpoint in endpoints_to_try:
        logger.debug(f"Trying endpoint: {endpoint}")
        try:
            vulnerabilities = _fetch_from_endpoint(
                session, endpoint, insecure, page, per_page, fetch_all_pages
            )
            if vulnerabilities:
                logger.info(f"Found {len(vulnerabilities)} vulnerabilities from {endpoint}")
                all_vulnerabilities = vulnerabilities
                break
            else:
                logger.debug(f"No results from {endpoint}")
        except requests.HTTPError as e:
            if e.response is not None and e.response.status_code == 404:
                logger.debug(f"Endpoint {endpoint} returned 404 - trying next")
                continue
            last_error = e
            logger.warning(f"HTTP error from {endpoint}: {e}")
        except requests.RequestException as e:
            last_error = e
            logger.warning(f"Request error from {endpoint}: {e}")

    if not all_vulnerabilities and last_error:
        logger.error(f"All API endpoints failed for CPE {cpe}. Last error: {last_error}")
        return []

    if not all_vulnerabilities:
        logger.info(f"No vulnerabilities found for CPE: {cpe}")
        return []

    # Filter by date range (client-side filtering)
    filtered = _filter_by_date_range(all_vulnerabilities, since, until)
    logger.info(f"After date filtering: {len(filtered)} vulnerabilities (from {len(all_vulnerabilities)} total)")

    return filtered


def _fetch_from_endpoint(
    session: requests.Session,
    endpoint: str,
    insecure: bool,
    page: int,
    per_page: int,
    fetch_all_pages: bool,
) -> List[dict]:
    """Fetch vulnerabilities from a specific API endpoint with pagination."""
    all_vulnerabilities = []
    current_page = page

    while True:
        params = {
            "page": current_page,
            "per_page": min(per_page, 100),
        }

        response = _do_get(session, endpoint, insecure, params=params)

        if response.status_code == 404:
            raise requests.HTTPError(response=response)

        response.raise_for_status()

        try:
            data = response.json()
        except ValueError as e:
            logger.error(f"Invalid JSON response: {e}")
            logger.debug(f"Response content: {response.text[:500]}")
            return []

        # Handle different response formats
        vulnerabilities, metadata = _parse_api_response(data)

        if not vulnerabilities:
            logger.debug(f"No vulnerabilities in response from page {current_page}")
            break

        all_vulnerabilities.extend(vulnerabilities)
        logger.debug(f"Page {current_page}: got {len(vulnerabilities)} vulnerabilities")

        # Check if we should fetch more pages
        if not fetch_all_pages:
            break

        total_pages = metadata.get("total_pages", 1)
        total_count = metadata.get("total", len(all_vulnerabilities))

        if current_page >= total_pages:
            break

        # Safety limit
        if current_page >= 100:
            logger.warning(f"Reached page limit (100 pages, {len(all_vulnerabilities)} vulnerabilities)")
            break

        current_page += 1

    return all_vulnerabilities


def _parse_api_response(data: Any) -> tuple:
    """
    Parse API response which may come in different formats.

    Returns:
        Tuple of (vulnerabilities_list, metadata_dict)
    """
    metadata = {}

    if isinstance(data, dict):
        # Format 1: Paginated response with 'data' key
        if "data" in data:
            vulnerabilities = data.get("data", [])
            metadata = data.get("metadata", {})
            if not metadata and "pagination" in data:
                metadata = data.get("pagination", {})
        # Format 2: Results in 'results' or 'vulnerabilities' key
        elif "results" in data:
            vulnerabilities = data.get("results", [])
            metadata = {
                "total": data.get("total", len(vulnerabilities)),
                "total_pages": data.get("total_pages", 1),
            }
        elif "vulnerabilities" in data:
            vulnerabilities = data.get("vulnerabilities", [])
            metadata = {
                "total": data.get("total", len(vulnerabilities)),
                "total_pages": data.get("pages", 1),
            }
        # Format 3: Single vulnerability object
        elif "id" in data or "cve" in data:
            vulnerabilities = [data]
        else:
            # Unknown dict format - try to extract any list
            for key in data:
                if isinstance(data[key], list) and len(data[key]) > 0:
                    vulnerabilities = data[key]
                    break
            else:
                vulnerabilities = []
    elif isinstance(data, list):
        # Direct list response
        vulnerabilities = data
    else:
        vulnerabilities = []

    return vulnerabilities, metadata


def _filter_by_date_range(vulnerabilities: List[dict], since, until) -> List[dict]:
    """Filter vulnerabilities by date range."""
    filtered = []

    for vuln in vulnerabilities:
        if not isinstance(vuln, dict):
            continue

        # Get last modified date
        mod_date = _extract_vuln_date(vuln)

        if mod_date:
            # Include if modified within our time window
            if since <= mod_date <= until:
                filtered.append(vuln)
        else:
            # If no date found, include the vulnerability to be safe
            # but log a warning
            cve_id = vuln.get("id") or vuln.get("cve", {}).get("id", "unknown")
            logger.debug(f"No date found for {cve_id} - including in results")
            filtered.append(vuln)

    return filtered


def test_api_connection(session: requests.Session, insecure: bool = False) -> Dict[str, Any]:
    """
    Test connectivity to the Vulnerability-Lookup API.

    Returns:
        Dict with status information
    """
    result = {
        "success": False,
        "api_base": VULNERABILITY_LOOKUP_BASE,
        "endpoints_tested": [],
        "errors": [],
    }

    test_endpoints = [
        "/api/",
        "/api/last",
        "/api/dbinfo",
    ]

    for endpoint in test_endpoints:
        try:
            logger.info(f"Testing API endpoint: {endpoint}")
            response = _do_get(session, endpoint, insecure)

            result["endpoints_tested"].append({
                "endpoint": endpoint,
                "status": response.status_code,
                "success": response.status_code == 200,
            })

            if response.status_code == 200:
                result["success"] = True
                logger.info(f"API endpoint {endpoint} is accessible")
            else:
                logger.warning(f"API endpoint {endpoint} returned {response.status_code}")

        except Exception as e:
            result["errors"].append({
                "endpoint": endpoint,
                "error": str(e),
            })
            logger.error(f"Failed to connect to {endpoint}: {e}")

    return result

from typing import List, Optional, Dict, Any
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import urllib3

from .config import VULNERABILITY_LOOKUP_BASE, DEFAULT_TIMEOUT
from .utils import parse_iso

UA = "CPE-Watch/2.0 (+vulnerability-lookup)"


def build_session(https_proxy=None, http_proxy=None, ca_bundle=None, insecure=False, timeout=DEFAULT_TIMEOUT):
    """Build a requests session with retry logic and proxy support."""
    session = requests.Session()
    retry = Retry(
        total=4,
        backoff_factor=1.0,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=("GET",),
        raise_on_status=False,
    )
    session.mount("https://", HTTPAdapter(max_retries=retry))
    session.mount("http://", HTTPAdapter(max_retries=retry))

    proxies: Dict[str, str] = {}
    if http_proxy:
        proxies["http"] = http_proxy
    if https_proxy:
        proxies["https"] = https_proxy
    if proxies:
        session.proxies.update(proxies)

    if ca_bundle:
        session.verify = ca_bundle
    session.timeout = timeout

    if insecure:
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    return session


def _do_get(session: requests.Session, path: str, insecure: bool, url_base: str = VULNERABILITY_LOOKUP_BASE):
    """Execute GET request to Vulnerability-Lookup API."""
    headers = {
        "User-Agent": UA,
        "Accept": "application/json",
    }
    verify = False if insecure else getattr(session, "verify", True)
    timeout = getattr(session, "timeout", DEFAULT_TIMEOUT)
    full_url = f"{url_base}{path}"
    return session.get(full_url, headers=headers, verify=verify, timeout=timeout)


def _severity_from_score(score: Optional[float]) -> str:
    """Convert CVSS score to severity level."""
    if score is None:
        return "None"
    try:
        value = float(score)
    except Exception:
        return "None"
    if value >= 9.0:
        return "Critical"
    if value >= 7.0:
        return "High"
    if value >= 4.0:
        return "Medium"
    if value > 0.0:
        return "Low"
    return "None"


def _pick_cvss(vuln_data: Dict[str, Any]) -> Dict[str, Any]:
    """Extract best available CVSS metrics (prioritize v4 > v3.1 > v3.0 > v2)."""
    # Vulnerability-Lookup stores CVSS in different formats
    # Check for cvss-metrics array first
    cvss_metrics = vuln_data.get("cvss-metrics", [])

    # Priority order for CVSS versions
    for version_key in ("cvssV4_0", "cvssV3_1", "cvssV3_0", "cvssV2_0"):
        for metric in cvss_metrics:
            if version_key in metric:
                data = metric[version_key]
                score = data.get("baseScore")
                severity = data.get("baseSeverity") or _severity_from_score(score)
                return {
                    "version": data.get("version"),
                    "vector": data.get("vectorString"),
                    "baseScore": score,
                    "baseSeverity": severity,
                }

    # Fallback: try legacy cvss field
    cvss = vuln_data.get("cvss")
    if cvss:
        return {
            "version": "2.0",
            "vector": None,
            "baseScore": cvss,
            "baseSeverity": _severity_from_score(cvss),
        }

    return {"version": None, "vector": None, "baseScore": None, "baseSeverity": "None"}


def extract_metrics(vuln) -> Dict[str, Any]:
    """Extract CVSS metrics from vulnerability data."""
    return _pick_cvss(vuln)


def extract_epss(vuln) -> Dict[str, Any]:
    """Extract EPSS (Exploit Prediction Scoring System) data."""
    epss_data = vuln.get("epss", {})
    if isinstance(epss_data, dict):
        return {
            "score": epss_data.get("epss"),  # Probability of exploitation (0-1)
            "percentile": epss_data.get("percentile"),  # Percentile ranking
        }
    return {"score": None, "percentile": None}


def extract_description(vuln) -> str:
    """Extract vulnerability description."""
    # Try summary field first
    summary = vuln.get("summary", "").strip()
    if summary:
        return summary

    # Try descriptions array
    descriptions = vuln.get("descriptions", [])
    for entry in descriptions:
        if isinstance(entry, dict):
            if entry.get("lang", "").lower() == "en":
                value = entry.get("value", "").strip()
                if value:
                    return value

    # Fallback to any description
    for entry in descriptions:
        if isinstance(entry, dict):
            value = entry.get("value", "").strip()
            if value:
                return value

    return ""


def extract_cwes(vuln) -> List[str]:
    """Extract CWE (Common Weakness Enumeration) identifiers."""
    found: List[str] = []

    # Try cwe field (may be a list or single value)
    cwe = vuln.get("cwe")
    if cwe:
        if isinstance(cwe, list):
            for item in cwe:
                cwe_str = str(item).strip()
                if cwe_str and cwe_str not in found:
                    if not cwe_str.startswith("CWE-"):
                        cwe_str = f"CWE-{cwe_str}"
                    found.append(cwe_str)
        else:
            cwe_str = str(cwe).strip()
            if cwe_str:
                if not cwe_str.startswith("CWE-"):
                    cwe_str = f"CWE-{cwe_str}"
                found.append(cwe_str)

    # Try weaknesses array
    weaknesses = vuln.get("weaknesses", [])
    for weakness in weaknesses:
        if isinstance(weakness, dict):
            for desc in weakness.get("description", []):
                if isinstance(desc, dict):
                    value = desc.get("value", "").strip()
                    if value.startswith("CWE-") and value not in found:
                        found.append(value)

    return found


def extract_references(vuln) -> List[Dict[str, Any]]:
    """Extract reference URLs and their metadata."""
    references = []
    refs = vuln.get("references", [])

    for ref in refs:
        if isinstance(ref, dict):
            references.append({
                "url": ref.get("url"),
                "source": ref.get("source"),
                "tags": ref.get("tags") or [],
            })
        elif isinstance(ref, str):
            # Simple URL string
            references.append({
                "url": ref,
                "source": None,
                "tags": [],
            })

    return references


def is_kev(vuln) -> bool:
    """Check if vulnerability is in CISA Known Exploited Vulnerabilities catalog."""
    # Check for KEV data in various formats
    kev_data = vuln.get("kev", {})
    if isinstance(kev_data, dict) and kev_data:
        return True

    # Check for CISA fields
    cisa_fields = ("cisaExploitAdd", "cisaActionDue", "cisaRequiredAction", "cisaVulnerabilityName")
    if any(field in vuln for field in cisa_fields):
        return True

    # Check other field that might indicate KEV
    other = vuln.get("other", {})
    if isinstance(other, dict):
        content = other.get("content", {})
        if isinstance(content, dict) and content.get("type") == "kev":
            return True

    return False


def extract_kev_data(vuln) -> Dict[str, Any]:
    """Extract KEV-specific data (date added, required action, etc.)."""
    kev_info = {}

    # Try kev object
    kev_data = vuln.get("kev", {})
    if isinstance(kev_data, dict):
        kev_info = {
            "dateAdded": kev_data.get("dateAdded"),
            "dueDate": kev_data.get("dueDate"),
            "requiredAction": kev_data.get("requiredAction"),
            "vulnerabilityName": kev_data.get("vulnerabilityName"),
        }

    # Try other.content format
    other = vuln.get("other", {})
    if isinstance(other, dict):
        content = other.get("content", {})
        if isinstance(content, dict) and content.get("type") == "kev":
            kev_info = {
                "dateAdded": content.get("dateAdded"),
                "dueDate": content.get("dueDate"),
                "requiredAction": content.get("requiredAction"),
                "vulnerabilityName": content.get("vulnerabilityName"),
            }

    # Try CISA fields directly
    if not kev_info:
        kev_info = {
            "dateAdded": vuln.get("cisaExploitAdd"),
            "dueDate": vuln.get("cisaActionDue"),
            "requiredAction": vuln.get("cisaRequiredAction"),
            "vulnerabilityName": vuln.get("cisaVulnerabilityName"),
        }

    # Filter out None values
    return {k: v for k, v in kev_info.items() if v is not None}


def fetch_for_cpe(
    session: requests.Session,
    cpe: str,
    since,
    until,
    api_key: Optional[str],
    insecure: bool,
    no_rejected: bool = True,
) -> List[dict]:
    """
    Fetch vulnerabilities for a given CPE from Vulnerability-Lookup API.

    Note: Vulnerability-Lookup's /api/cvefor endpoint returns all CVEs for a CPE.
    Time filtering is done client-side since the API doesn't support date ranges.
    """
    # URL-encode the CPE for the API call
    import urllib.parse
    cpe_encoded = urllib.parse.quote(cpe, safe='')

    path = f"/cvefor/{cpe_encoded}"

    try:
        response = _do_get(session, path, insecure)
        response.raise_for_status()
        data = response.json()
    except requests.HTTPError as exc:
        # If 404, it might mean no vulnerabilities found - return empty list
        if exc.response and exc.response.status_code == 404:
            return []
        raise
    except Exception:
        # For any other error, return empty list
        return []

    # Response can be a list of vulnerabilities or a dict with results
    if isinstance(data, list):
        vulnerabilities = data
    elif isinstance(data, dict):
        # Try different response formats
        vulnerabilities = data.get("results", data.get("vulnerabilities", []))
    else:
        vulnerabilities = []

    # Filter by date range (client-side filtering)
    filtered = []
    for vuln in vulnerabilities:
        if not isinstance(vuln, dict):
            continue

        # Get last modified date
        last_modified = vuln.get("last-modified") or vuln.get("lastModified") or vuln.get("modified")
        if last_modified:
            try:
                mod_date = parse_iso(last_modified)
                # Include if modified within our time window
                if since <= mod_date <= until:
                    filtered.append(vuln)
            except Exception:
                # If date parsing fails, include the vulnerability to be safe
                filtered.append(vuln)
        else:
            # If no date, include it
            filtered.append(vuln)

    return filtered

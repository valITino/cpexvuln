import pathlib
import sys
from datetime import datetime, timedelta, timezone

ROOT = pathlib.Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from app import vulnerabilitylookup  # noqa: E402


def test_extract_metrics_cvss_v31():
    vuln = {
        "cvss-metrics": [
            {
                "cvssV3_1": {
                    "version": "3.1",
                    "baseScore": 7.5,
                    "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "baseSeverity": "HIGH"
                }
            }
        ]
    }
    result = vulnerabilitylookup.extract_metrics(vuln)
    assert result["version"] == "3.1"
    assert result["baseScore"] == 7.5
    assert result["baseSeverity"] == "HIGH"


def test_extract_metrics_prefers_v4():
    vuln = {
        "cvss-metrics": [
            {
                "cvssV3_1": {
                    "version": "3.1",
                    "baseScore": 7.5,
                    "vectorString": "CVSS:3.1/...",
                    "baseSeverity": "High"
                }
            },
            {
                "cvssV4_0": {
                    "version": "4.0",
                    "baseScore": 8.3,
                    "vectorString": "CVSS:4.0/...",
                    "baseSeverity": "Critical"
                }
            }
        ]
    }
    result = vulnerabilitylookup.extract_metrics(vuln)
    assert result["version"] == "4.0"
    assert result["baseScore"] == 8.3
    assert result["baseSeverity"] == "Critical"


def test_extract_metrics_from_cna_metrics():
    vuln = {
        "containers": {
            "cna": {
                "metrics": [
                    {
                        "cvssV3_1": {
                            "version": "3.1",
                            "baseScore": 6.4,
                            "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
                            "baseSeverity": "Medium",
                        }
                    }
                ]
            }
        }
    }
    result = vulnerabilitylookup.extract_metrics(vuln)
    assert result["version"] == "3.1"
    assert result["baseScore"] == 6.4
    assert result["baseSeverity"] == "Medium"


def test_extract_epss():
    vuln = {
        "epss": {
            "epss": 0.75123,
            "percentile": 0.95432
        }
    }
    result = vulnerabilitylookup.extract_epss(vuln)
    assert result["score"] == 0.75123
    assert result["percentile"] == 0.95432


def test_extract_epss_missing():
    vuln = {}
    result = vulnerabilitylookup.extract_epss(vuln)
    assert result["score"] is None
    assert result["percentile"] is None


def test_extract_epss_string_value():
    vuln = {"epss": "0.42"}
    result = vulnerabilitylookup.extract_epss(vuln)
    assert result["score"] == 0.42
    assert result["percentile"] is None


def test_fetch_epss_first_parses_data():
    class FakeResponse:
        status_code = 200

        def raise_for_status(self):
            pass

        def json(self):
            return {"data": [{"epss": "0.0123", "percentile": "0.56"}]}

    class FakeSession:
        def __init__(self):
            self.verify = True
            self.timeout = 10

        def get(self, *args, **kwargs):
            return FakeResponse()

    result = vulnerabilitylookup.fetch_epss_first(FakeSession(), "CVE-2024-0001", insecure=False)
    assert result["score"] == 0.0123
    assert result["percentile"] == 0.56


def test_fetch_nvd_cvss_parses_metrics():
    class FakeResponse:
        status_code = 200

        def raise_for_status(self):
            pass

        def json(self):
            return {
                "vulnerabilities": [
                    {
                        "cve": {
                            "metrics": {
                                "cvssMetricV31": [
                                    {
                                        "cvssData": {
                                            "version": "3.1",
                                            "baseScore": 7.8,
                                            "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N",
                                        },
                                        "baseSeverity": "HIGH",
                                    }
                                ]
                            }
                        }
                    }
                ]
            }

    class FakeSession:
        def __init__(self):
            self.verify = True
            self.timeout = 10

        def get(self, *args, **kwargs):
            return FakeResponse()

    result = vulnerabilitylookup.fetch_nvd_cvss(FakeSession(), "CVE-2024-0001", insecure=False)
    assert result["version"] == "3.1"
    assert result["baseScore"] == 7.8
    assert result["baseSeverity"] == "HIGH"


def test_is_kev_true():
    vuln = {
        "kev": {
            "dateAdded": "2024-01-15",
            "dueDate": "2024-02-15"
        }
    }
    assert vulnerabilitylookup.is_kev(vuln) is True


def test_is_kev_false():
    vuln = {}
    assert vulnerabilitylookup.is_kev(vuln) is False


def test_extract_kev_data():
    vuln = {
        "kev": {
            "dateAdded": "2024-01-15",
            "dueDate": "2024-02-15",
            "requiredAction": "Apply updates",
            "vulnerabilityName": "Critical RCE"
        }
    }
    result = vulnerabilitylookup.extract_kev_data(vuln)
    assert result["dateAdded"] == "2024-01-15"
    assert result["dueDate"] == "2024-02-15"
    assert result["requiredAction"] == "Apply updates"
    assert result["vulnerabilityName"] == "Critical RCE"


def test_extract_description():
    vuln = {
        "summary": "This is a test vulnerability description"
    }
    result = vulnerabilitylookup.extract_description(vuln)
    assert result == "This is a test vulnerability description"


def test_extract_description_from_cna():
    vuln = {
        "containers": {
            "cna": {
                "descriptions": [
                    {"lang": "en", "value": "CNA description here."}
                ]
            }
        }
    }
    result = vulnerabilitylookup.extract_description(vuln)
    assert result == "CNA description here."


def test_extract_source_identifier():
    vuln = {
        "cveMetadata": {
            "assignerShortName": "example-cna"
        },
        "containers": {
            "cna": {
                "providerMetadata": {
                    "shortName": "should-not-win"
                }
            }
        }
    }
    assert vulnerabilitylookup.extract_source_identifier(vuln) == "example-cna"


def test_extract_cwes():
    vuln = {
        "cwe": ["79", "89"]
    }
    result = vulnerabilitylookup.extract_cwes(vuln)
    assert "CWE-79" in result
    assert "CWE-89" in result


def test_extract_cwes_from_cna_problem_types():
    vuln = {
        "containers": {
            "cna": {
                "problemTypes": [
                    {
                        "descriptions": [
                            {"lang": "en", "description": "CWE-79"}
                        ]
                    }
                ]
            }
        }
    }
    result = vulnerabilitylookup.extract_cwes(vuln)
    assert "CWE-79" in result


def test_extract_references():
    vuln = {
        "references": [
            {
                "url": "https://example.com/advisory",
                "source": "vendor",
                "tags": ["Patch", "Vendor Advisory"]
            },
            {
                "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-1234",
                "source": "NVD",
                "tags": []
            }
        ]
    }
    result = vulnerabilitylookup.extract_references(vuln)
    assert len(result) == 2
    assert result[0]["url"] == "https://example.com/advisory"
    assert result[0]["tags"] == ["Patch", "Vendor Advisory"]


def test_extract_references_from_cna():
    vuln = {
        "containers": {
            "cna": {
                "references": [
                    {"url": "https://example.com/cna", "source": "CNA", "tags": ["Vendor Advisory"]}
                ]
            }
        }
    }
    result = vulnerabilitylookup.extract_references(vuln)
    assert len(result) == 1
    assert result[0]["url"] == "https://example.com/cna"
    assert result[0]["source"] == "CNA"


def test_extract_cve_id_cvelistv5():
    vuln = {
        "cveMetadata": {
            "cveId": "CVE-2024-9999"
        }
    }
    assert vulnerabilitylookup.extract_cve_id(vuln) == "CVE-2024-9999"


def test_severity_from_score():
    assert vulnerabilitylookup._severity_from_score(9.5) == "Critical"
    assert vulnerabilitylookup._severity_from_score(8.0) == "High"
    assert vulnerabilitylookup._severity_from_score(5.0) == "Medium"
    assert vulnerabilitylookup._severity_from_score(2.0) == "Low"
    assert vulnerabilitylookup._severity_from_score(None) == "None"


def test_fetch_for_cpe_filters_by_date(monkeypatch):
    """Test that fetch_for_cpe filters results by date range."""
    now = datetime.now(timezone.utc)
    since = now - timedelta(days=2)
    until = now

    # Mock response with mixed dates in paginated format
    mock_vulns = [
        {"id": "CVE-2024-0001", "lastModified": (now - timedelta(days=1)).strftime("%Y-%m-%dT%H:%M:%S.000Z")},
        {"id": "CVE-2024-0002", "lastModified": (now - timedelta(days=5)).strftime("%Y-%m-%dT%H:%M:%S.000Z")},
        {"id": "CVE-2024-0003", "lastModified": now.strftime("%Y-%m-%dT%H:%M:%S.000Z")},
    ]

    class FakeResponse:
        status_code = 200

        def raise_for_status(self):
            pass

        def json(self):
            # Return paginated response format
            return {
                "data": mock_vulns,
                "metadata": {
                    "page": 1,
                    "per_page": 100,
                    "total_pages": 1
                }
            }

    def fake_get(session, path, insecure, params=None):
        return FakeResponse()

    monkeypatch.setattr(vulnerabilitylookup, "_do_get", fake_get)

    class FakeSession:
        pass

    results = vulnerabilitylookup.fetch_for_cpe(
        session=FakeSession(),
        cpe="cpe:2.3:a:test:test:1.0:*:*:*:*:*:*:*",
        since=since,
        until=until,
        insecure=False
    )

    # Should only include CVEs within the date range (not the one from 5 days ago)
    assert len(results) == 2
    assert results[0]["id"] == "CVE-2024-0001"
    assert results[1]["id"] == "CVE-2024-0003"


def test_fetch_for_cpe_handles_source_keyed_response(monkeypatch):
    now = datetime.now(timezone.utc)
    since = now - timedelta(days=2)
    until = now

    class FakeResponse:
        status_code = 200

        def raise_for_status(self):
            pass

        def json(self):
            return {
                "cvelistv5": [
                    {"id": "CVE-2024-0001", "lastModified": now.strftime("%Y-%m-%dT%H:%M:%S.000Z")}
                ]
            }

    def fake_get(session, path, insecure, params=None):
        return FakeResponse()

    monkeypatch.setattr(vulnerabilitylookup, "_do_get", fake_get)

    class FakeSession:
        pass

    results = vulnerabilitylookup.fetch_for_cpe(
        session=FakeSession(),
        cpe="cpe:2.3:a:test:test:1.0:*:*:*:*:*:*:*",
        since=since,
        until=until,
        insecure=False,
    )

    assert len(results) == 1
    assert results[0]["id"] == "CVE-2024-0001"


def test_fetch_for_cpe_handles_pagination(monkeypatch):
    """Test that fetch_for_cpe handles multi-page responses."""
    now = datetime.now(timezone.utc)
    since = now - timedelta(days=30)
    until = now

    page_responses = {
        1: {
            "data": [{"id": "CVE-2024-0001", "lastModified": now.strftime("%Y-%m-%dT%H:%M:%S.000Z")}],
            "metadata": {"page": 1, "per_page": 1, "total_pages": 2}
        },
        2: {
            "data": [{"id": "CVE-2024-0002", "lastModified": now.strftime("%Y-%m-%dT%H:%M:%S.000Z")}],
            "metadata": {"page": 2, "per_page": 1, "total_pages": 2}
        }
    }

    class FakeResponse:
        def __init__(self, page):
            self.page = page
            self.status_code = 200

        def raise_for_status(self):
            pass

        def json(self):
            return page_responses[self.page]

    def fake_get(session, path, insecure, params=None):
        page = params.get("page", 1) if params else 1
        return FakeResponse(page)

    monkeypatch.setattr(vulnerabilitylookup, "_do_get", fake_get)

    class FakeSession:
        pass

    results = vulnerabilitylookup.fetch_for_cpe(
        session=FakeSession(),
        cpe="cpe:2.3:a:test:test:1.0:*:*:*:*:*:*:*",
        since=since,
        until=until,
        insecure=False,
        fetch_all_pages=True
    )

    # Should fetch both pages
    assert len(results) == 2
    assert results[0]["id"] == "CVE-2024-0001"
    assert results[1]["id"] == "CVE-2024-0002"


def test_extract_vuln_date_nvd_format():
    """Test date extraction from NVD format vulnerability."""
    vuln = {"lastModified": "2024-01-15T12:00:00.000Z"}
    result = vulnerabilitylookup._extract_vuln_date(vuln)
    assert result is not None
    assert result.year == 2024
    assert result.month == 1
    assert result.day == 15


def test_extract_vuln_date_cve_metadata():
    """Test date extraction from cveMetadata format."""
    vuln = {
        "cveMetadata": {
            "dateUpdated": "2024-02-20T10:30:00.000Z"
        }
    }
    result = vulnerabilitylookup._extract_vuln_date(vuln)
    assert result is not None
    assert result.year == 2024
    assert result.month == 2
    assert result.day == 20


def test_fetch_nvd_cvss_success(monkeypatch):
    """Test fetching CVSS from NVD API when primary source lacks scores."""
    # Clear cache before test
    vulnerabilitylookup._NVD_CACHE.clear()

    class FakeResponse:
        status_code = 200

        def raise_for_status(self):
            pass

        def json(self):
            return {
                "vulnerabilities": [
                    {
                        "cve": {
                            "id": "CVE-2024-1234",
                            "metrics": {
                                "cvssMetricV31": [
                                    {
                                        "cvssData": {
                                            "version": "3.1",
                                            "baseScore": 9.8,
                                            "baseSeverity": "CRITICAL",
                                            "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
                                        }
                                    }
                                ]
                            }
                        }
                    }
                ]
            }

    class FakeSession:
        timeout = 60

        def get(self, url, **kwargs):
            return FakeResponse()

    result = vulnerabilitylookup.fetch_nvd_cvss(FakeSession(), "CVE-2024-1234", False)

    assert result["baseScore"] == 9.8
    assert result["baseSeverity"] == "CRITICAL"
    assert result["version"] == "3.1"
    assert "CVSS:3.1" in result["vector"]


def test_fetch_nvd_cvss_not_found(monkeypatch):
    """Test handling of 404 response from NVD API."""
    vulnerabilitylookup._NVD_CACHE.clear()

    class FakeResponse:
        status_code = 404

        def raise_for_status(self):
            pass

    class FakeSession:
        timeout = 60

        def get(self, url, **kwargs):
            return FakeResponse()

    result = vulnerabilitylookup.fetch_nvd_cvss(FakeSession(), "CVE-9999-9999", False)

    assert result["baseScore"] is None
    assert result["baseSeverity"] == "None"


def test_fetch_nvd_cvss_caching(monkeypatch):
    """Test that CVSS results are cached to avoid repeated API calls."""
    vulnerabilitylookup._NVD_CACHE.clear()

    call_count = [0]

    class FakeResponse:
        status_code = 200

        def raise_for_status(self):
            pass

        def json(self):
            return {
                "vulnerabilities": [
                    {
                        "cve": {
                            "id": "CVE-2024-5678",
                            "metrics": {
                                "cvssMetricV31": [
                                    {
                                        "cvssData": {
                                            "version": "3.1",
                                            "baseScore": 7.5,
                                            "baseSeverity": "HIGH",
                                            "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
                                        }
                                    }
                                ]
                            }
                        }
                    }
                ]
            }

    class FakeSession:
        timeout = 60

        def get(self, url, **kwargs):
            call_count[0] += 1
            return FakeResponse()

    # First call should hit the API
    result1 = vulnerabilitylookup.fetch_nvd_cvss(FakeSession(), "CVE-2024-5678", False)
    assert result1["baseScore"] == 7.5
    assert call_count[0] == 1

    # Second call should use cache
    result2 = vulnerabilitylookup.fetch_nvd_cvss(FakeSession(), "CVE-2024-5678", False)
    assert result2["baseScore"] == 7.5
    assert call_count[0] == 1  # No additional API call


def test_fetch_nvd_cvss_rate_limited(monkeypatch):
    """Test handling of 403 rate limit response - should not cache."""
    vulnerabilitylookup._NVD_CACHE.clear()

    class FakeResponse:
        status_code = 403

        def raise_for_status(self):
            pass

    class FakeSession:
        timeout = 60

        def get(self, url, **kwargs):
            return FakeResponse()

    result = vulnerabilitylookup.fetch_nvd_cvss(FakeSession(), "CVE-2024-RATE", False)

    assert result["baseScore"] is None
    # Should not be cached on rate limit
    assert "CVE-2024-RATE" not in vulnerabilitylookup._NVD_CACHE


def test_fetch_nvd_cvss_empty_vulnerability_id():
    """Test handling of empty vulnerability ID."""
    result = vulnerabilitylookup.fetch_nvd_cvss(None, "", False)
    assert result["baseScore"] is None
    assert result["baseSeverity"] == "None"
